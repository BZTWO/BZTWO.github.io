<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>模板类与友元.md</title>
      <link href="/2024/02/13/%E6%A8%A1%E6%9D%BF%E7%B1%BB%E4%B8%8E%E5%8F%8B%E5%85%83-md/"/>
      <url>/2024/02/13/%E6%A8%A1%E6%9D%BF%E7%B1%BB%E4%B8%8E%E5%8F%8B%E5%85%83-md/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>非模板友元；</li><li>约束（bound）模板友元，即友元的类型取决于类被实例化时的类型；</li><li>非约束（unbound）模板友元，即友元的所有具体化都是类的每一个具体化的友元。</li></ul><h4 id="非模板友元"><a href="#非模板友元" class="headerlink" title="非模板友元"></a>非模板友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="type">int</span> secret;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> s) : <span class="built_in">secret</span>(s) &#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">revealSecret</span><span class="params">(MyClass&amp; obj)</span></span>;  <span class="comment">// 声明非模板友元函数  </span></span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">revealSecret</span><span class="params">(MyClass&amp; obj)</span> </span>&#123;  </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The secret is: &quot;</span> &lt;&lt; obj.secret &lt;&lt; std::endl;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">42</span>)</span></span>;  </span><br><span class="line">    <span class="built_in">revealSecret</span>(obj);  <span class="comment">// 可以访问obj的私有成员secret  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有类型共用一个友元函数。</p><h4 id="约束（bound）模板友元"><a href="#约束（bound）模板友元" class="headerlink" title="约束（bound）模板友元"></a>约束（bound）模板友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    T secret;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">MyClass</span>(T s) : <span class="built_in">secret</span>(s) &#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U = T, std::<span class="type">enable_if_t</span>&lt;std::is_integral_v&lt;U&gt;, <span class="type">int</span>&gt; = <span class="number">0</span>&gt;  </span><br><span class="line">    <span class="keyword">friend</span> <span class="type">void</span> <span class="built_in">revealSecret</span>(MyClass&lt;U&gt;&amp; obj);  <span class="comment">// 约束模板友元函数  </span></span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">revealSecret</span><span class="params">(MyClass&lt;T&gt;&amp; obj)</span> <span class="keyword">requires</span> std::integral_constant&lt;T&gt; </span>&#123;  </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The secret is: &quot;</span> &lt;&lt; obj.secret &lt;&lt; std::endl;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="function">MyClass&lt;<span class="type">int</span>&gt; <span class="title">obj</span><span class="params">(<span class="number">42</span>)</span></span>;  </span><br><span class="line">    <span class="built_in">revealSecret</span>(obj);  <span class="comment">// 可以访问obj的私有成员secret，因为int是整数类型  </span></span><br><span class="line">    <span class="comment">// MyClass&lt;std::string&gt; strObj(&quot;hello&quot;);  </span></span><br><span class="line">    <span class="comment">// revealSecret(strObj);  // 这行代码会编译失败，因为std::string不是整数类型  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个类有其特有类型的友元函数，不同类之间不共用，同类之间共用。</p><h4 id="非约束（unbound）模板友元"><a href="#非约束（unbound）模板友元" class="headerlink" title="非约束（unbound）模板友元"></a>非约束（unbound）模板友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    T secret;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">MyClass</span>(T s) : <span class="built_in">secret</span>(s) &#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;  </span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">revealSecret</span><span class="params">(MyClass&lt;U&gt;&amp; obj)</span></span>;  <span class="comment">// 非约束模板友元函数  </span></span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">revealSecret</span><span class="params">(MyClass&lt;T&gt;&amp; obj)</span> </span>&#123;  </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The secret is: &quot;</span> &lt;&lt; obj.secret &lt;&lt; std::endl;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="function">MyClass&lt;<span class="type">int</span>&gt; <span class="title">obj</span><span class="params">(<span class="number">42</span>)</span></span>;  </span><br><span class="line">    <span class="built_in">revealSecret</span>(obj);  <span class="comment">// 可以访问obj的私有成员secret  </span></span><br><span class="line">    <span class="function">MyClass&lt;std::string&gt; <span class="title">strObj</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;  </span><br><span class="line">    <span class="built_in">revealSecret</span>(strObj);  <span class="comment">// 也可以访问strObj的私有成员secret，因为没有约束  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模板具体化.md</title>
      <link href="/2024/02/12/%E6%A8%A1%E6%9D%BF%E5%85%B7%E4%BD%93%E5%8C%96-md/"/>
      <url>/2024/02/12/%E6%A8%A1%E6%9D%BF%E5%85%B7%E4%BD%93%E5%8C%96-md/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>类模板与函数模板很相似，因为可以有隐式实例化、显式实例化和显式具体化，它们统称为具体化（specialization）。模板以泛型的方式描述类，而具体化是使用具体的类型生成类声明。</p><h4 id="隐式实例化"><a href="#隐式实例化" class="headerlink" title="隐式实例化"></a>隐式实例化</h4><p>声明一个或多个对象，并指出所需的类型，而编译器使用通用模板提供的定义来生成具体的类定义，这称为隐式实例化（implicit instantiation）。</p><p>隐式实例化发生在编译器遇到对模板类的使用，但尚未为该特定类型生成实例化代码时。编译器会自动根据模板定义和所提供的类型参数生成相应的类代码。这个过程对用户是透明的，不需要显式地请求编译器为特定类型生成模板类的实例化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 通用模板类定义  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">MyClass</span>(T value) : <span class="built_in">m_value</span>(value) &#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; m_value &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    T m_value;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 隐式实例化 MyClass&lt;int&gt;  </span></span><br><span class="line">    <span class="function">MyClass&lt;<span class="type">int</span>&gt; <span class="title">intObj</span><span class="params">(<span class="number">42</span>)</span></span>;  </span><br><span class="line">    intObj.<span class="built_in">print</span>(); <span class="comment">// 输出: Value: 42  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 隐式实例化 MyClass&lt;double&gt;  </span></span><br><span class="line">    <span class="function">MyClass&lt;<span class="type">double</span>&gt; <span class="title">doubleObj</span><span class="params">(<span class="number">3.14</span>)</span></span>;  </span><br><span class="line">    doubleObj.<span class="built_in">print</span>(); <span class="comment">// 输出: Value: 3.14  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="显示实例化"><a href="#显示实例化" class="headerlink" title="显示实例化"></a>显示实例化</h4><p>显示实例化（explicit instantiation）是当你显式地请求编译器为特定类型生成模板类的实例化代码。这可以通过在模板类定义之外使用特定的语法来实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 通用模板类定义  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">MyClass</span>(T value) : <span class="built_in">m_value</span>(value) &#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value of type &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(T).<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; m_value &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    T m_value;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">int</span>&gt;;  <span class="comment">// 显示实例化 MyClass&lt;int&gt;  </span></span><br><span class="line"><span class="keyword">template</span> <span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">double</span>&gt;;  <span class="comment">// 显示实例化 MyClass&lt;double&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 由于已经进行了显示实例化，所以这里可以直接使用 MyClass&lt;int&gt;  </span></span><br><span class="line">    <span class="function">MyClass&lt;<span class="type">int</span>&gt; <span class="title">intObj</span><span class="params">(<span class="number">42</span>)</span></span>;  </span><br><span class="line">    intObj.<span class="built_in">print</span>(); <span class="comment">// 输出: Value of type i, probably &#x27;i&#x27; for &#x27;int&#x27;: 42  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="显示具体化"><a href="#显示具体化" class="headerlink" title="显示具体化"></a>显示具体化</h4><p>显式具体化（explicit specialization）是特定类型（用于替换模板中 的泛型）的定义。有时候，可能需要在为特殊类型实例化时，对模板进 行修改，使其行为不同。在这种情况下，可以创建显式具体化。例如， 假设已经为用于表示排序后数组的类（元素在加入时被排序）定义了一 个模板。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 通用模板类定义  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SortedArray</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(T value)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 在通用模板中，我们简单地将新值插入到数组中，并保持数组排序  </span></span><br><span class="line">        <span class="keyword">auto</span> it = std::<span class="built_in">lower_bound</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(), value);  </span><br><span class="line">        data.<span class="built_in">insert</span>(it, value);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; value : data) &#123;  </span><br><span class="line">            std::cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        std::cout &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    std::vector&lt;T&gt; data;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 显式具体化针对 int 类型  </span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SortedArray</span>&lt;<span class="type">int</span>&gt; &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 在 int 类型的特化版本中，我们在添加元素之前做一些额外的操作  </span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Adding an integer: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 调用通用模板的 add 方法（如果需要的话）  </span></span><br><span class="line">        <span class="comment">// SortedArray&lt;int&gt;::add(value); // 如果需要的话，可以显式调用  </span></span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 或者，提供 int 类型特定的实现  </span></span><br><span class="line">        data.<span class="built_in">push_back</span>(value);  </span><br><span class="line">        std::<span class="built_in">sort</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>()); <span class="comment">// 保持数组排序，但这不是最高效的做法  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; value : data) &#123;  </span><br><span class="line">            std::cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        std::cout &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    SortedArray&lt;<span class="type">float</span>&gt; floatArray;  </span><br><span class="line">    floatArray.<span class="built_in">add</span>(<span class="number">3.14f</span>);  </span><br><span class="line">    floatArray.<span class="built_in">add</span>(<span class="number">2.71f</span>);  </span><br><span class="line">    floatArray.<span class="built_in">print</span>(); <span class="comment">// 输出排序后的浮点数数组  </span></span><br><span class="line">  </span><br><span class="line">    SortedArray&lt;<span class="type">int</span>&gt; intArray;  </span><br><span class="line">    intArray.<span class="built_in">add</span>(<span class="number">3</span>);  </span><br><span class="line">    intArray.<span class="built_in">add</span>(<span class="number">1</span>);  </span><br><span class="line">    intArray.<span class="built_in">add</span>(<span class="number">2</span>);  </span><br><span class="line">    intArray.<span class="built_in">print</span>(); <span class="comment">// 输出排序后的整数数组，同时在添加时输出额外信息  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="部分具体化"><a href="#部分具体化" class="headerlink" title="部分具体化"></a>部分具体化</h4><p>类模板的部分具体化（Partial Specialization）是C++模板编程中的一个高级特性，它允许你为模板类的某些特定类型组合提供专门的实现。部分具体化不同于普通的模板特化（Template Specialization），后者是为整个模板提供特定的实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 通用模板类  </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;General template class.&quot;</span> &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 部分具体化：针对T1为int，T2为double的情况  </span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">int</span>, <span class="type">double</span>&gt; &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Partial specialization for int and double.&quot;</span> &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 部分具体化：针对T1为double，T2为int的情况  </span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">double</span>, <span class="type">int</span>&gt; &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Partial specialization for double and int.&quot;</span> &lt;&lt; std::endl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    MyClass&lt;<span class="type">int</span>, <span class="type">double</span>&gt; obj1;  </span><br><span class="line">    obj1.<span class="built_in">print</span>();  <span class="comment">// 输出：Partial specialization for int and double.  </span></span><br><span class="line">  </span><br><span class="line">    MyClass&lt;<span class="type">double</span>, <span class="type">int</span>&gt; obj2;  </span><br><span class="line">    obj2.<span class="built_in">print</span>();  <span class="comment">// 输出：Partial specialization for double and int.  </span></span><br><span class="line">  </span><br><span class="line">    MyClass&lt;<span class="type">int</span>, <span class="type">int</span>&gt; obj3;  </span><br><span class="line">    obj3.<span class="built_in">print</span>();  <span class="comment">// 输出：General template class.  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数模板显示具体化"><a href="#函数模板显示具体化" class="headerlink" title="函数模板显示具体化"></a>函数模板显示具体化</h4><p>显式具体化是直接为某个特定类型提供模板函数的实现。这种方式需要明确地指定类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(T t)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 通用版本的实现  </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;General template: &quot;</span> &lt;&lt; t &lt;&lt; std::endl;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 显式具体化为int类型  </span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;  </span><br><span class="line"><span class="type">void</span> <span class="built_in">foo</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span> t) &#123;  </span><br><span class="line">    <span class="comment">// int类型的特定实现  </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Specialized template for int: &quot;</span> &lt;&lt; t &lt;&lt; std::endl;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="built_in">foo</span>(<span class="number">3.14</span>);  <span class="comment">// 调用通用版本  </span></span><br><span class="line">    <span class="built_in">foo</span>(<span class="number">42</span>);    <span class="comment">// 调用int类型的特定版本  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数模板隐式具体化"><a href="#函数模板隐式具体化" class="headerlink" title="函数模板隐式具体化"></a>函数模板隐式具体化</h4><p>隐式具体化是编译器自动为某些特定类型提供模板函数的实现。这通常是通过提供一个非模板函数来实现的，该函数的签名与模板函数签名在除了返回类型之外的所有方面都相同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(T t)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 通用版本的实现  </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;General template: &quot;</span> &lt;&lt; t &lt;&lt; std::endl;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 隐式具体化为int类型  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(<span class="type">int</span> t)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// int类型的特定实现  </span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Implicit specialized template for int: &quot;</span> &lt;&lt; t &lt;&lt; std::endl;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="built_in">bar</span>(<span class="number">3.14</span>);  <span class="comment">// 调用通用版本  </span></span><br><span class="line">    <span class="built_in">bar</span>(<span class="number">42</span>);    <span class="comment">// 调用int类型的隐式具体化版本  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>static-dynamic.md</title>
      <link href="/2024/02/07/static-dynamic-md/"/>
      <url>/2024/02/07/static-dynamic-md/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>在C++中，动态转换（<code>dynamic_cast</code>）和静态转换（<code>static_cast</code>）是用于在类型之间进行转换的两种机制，但它们的用途、行为以及安全保证是不同的。</p><h4 id="静态转换-static-cast"><a href="#静态转换-static-cast" class="headerlink" title="静态转换(static_cast)"></a>静态转换(static_cast)</h4><p><code>static_cast</code> 是最通用的转换运算符，它可以在多种类型之间进行转换，包括非多态类型之间的转换、基本数据类型之间的转换、指针之间的转换（包括空指针到任何指针类型的转换），以及类层次结构中的向上转换（从派生类到基类）。</p><ul><li>对于类层次结构中的向上转换，<code>static_cast</code> 总是成功的。</li><li>对于向下或侧向转换，<code>static_cast</code> 假设程序员知道转换是安全的，并且不会进行运行时检查。如果转换实际上是不安全的，结果将是未定义的。</li></ul><p><strong>安全保证</strong>：<code>static_cast</code> 不提供运行时类型信息检查。如果程序员错误地使用了它进行不安全的转换，程序可能会崩溃或产生不可预测的行为。</p><p><strong>使用条件</strong>：<code>static_cast</code> 不需要基类具有虚函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 基本数据类型之间的转换</span></span><br><span class="line"><span class="type">double</span> d = <span class="number">3.14</span>;  </span><br><span class="line"><span class="type">int</span> i = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(d); <span class="comment">// 将 double 转换为 int，结果为 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 指针和引用之间的转换</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>;  </span><br><span class="line"><span class="type">int</span>* p = &amp;x;  </span><br><span class="line"><span class="type">int</span>&amp; r = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&amp;&gt;(*p); <span class="comment">// 将 int* 转换为 int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 类层次结构中的向上转换</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; &#125;;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123; &#125;;  </span><br><span class="line">  </span><br><span class="line">Derived d;  </span><br><span class="line">Base&amp; b = <span class="built_in">static_cast</span>&lt;Base&amp;&gt;(d); <span class="comment">// 派生类对象转换为基类引用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 编译时确定安全的向下转换</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; &#125;;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123; <span class="keyword">public</span>: <span class="type">int</span> value; &#125;;  </span><br><span class="line">  </span><br><span class="line">Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();  </span><br><span class="line">Derived* derivedPtr = <span class="built_in">static_cast</span>&lt;Derived*&gt;(basePtr); <span class="comment">// 安全的，因为确实是指向 Derived 对象的  </span></span><br><span class="line">derivedPtr-&gt;value = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 去除 const 或 volatile 修饰符</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;  </span><br><span class="line"><span class="type">int</span>* ptr = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;a); <span class="comment">// 错误！const_cast 用于去除 const，不是 static_cast  </span></span><br><span class="line"><span class="type">int</span>* constPtr = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>*&gt;(<span class="built_in">const_cast</span>&lt;<span class="type">const</span> <span class="type">int</span>*&gt;(&amp;a)); <span class="comment">// 正确！先去除 const，然后转换为 int*</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//6. 数组到指针的转换</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];  </span><br><span class="line"><span class="type">int</span>* ptr = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>*&gt;(arr); <span class="comment">// 数组名转换为指向数组首元素的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//7. 函数指针的转换</span></span><br><span class="line"><span class="built_in">void</span> (*func1)();  </span><br><span class="line"><span class="built_in">void</span> (*func2)(<span class="type">int</span>);  </span><br><span class="line">func1 = <span class="built_in">static_cast</span>&lt;<span class="built_in">void</span> (*)()&gt;(func2); <span class="comment">// 将接受 int 的函数指针转换为不接受参数的函数指针</span></span><br></pre></td></tr></table></figure><h4 id="动态转换-dynamic-cast"><a href="#动态转换-dynamic-cast" class="headerlink" title="动态转换(dynamic_cast)"></a>动态转换(dynamic_cast)</h4><p><code>dynamic_cast</code> 主要用于在类层次结构中进行安全的向下和侧向转换（即从基类到派生类或派生类之间的转换）。</p><ul><li>如果转换是合法的（即目标类型是实际对象的类型或其派生类型），<code>dynamic_cast</code> 会成功转换并返回目标类型的指针或引用。</li><li>如果转换不合法（例如，尝试将基类指针转换为不相关的派生类类型），<code>dynamic_cast</code> 会返回空指针（对于指针类型）或抛出异常（对于引用类型）。</li></ul><p><strong>安全保证</strong>：<code>dynamic_cast</code> 提供运行时类型信息（RTTI）检查，以确保转换的安全性。如果转换失败，程序不会崩溃，而是得到空指针或异常，从而可以安全地处理错误情况。</p><p><strong>使用条件</strong>：为了使用 <code>dynamic_cast</code>，基类必须至少有一个虚函数，这样编译器才能生成运行时类型信息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 基类  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>() &#123;&#125; <span class="comment">// 声明虚析构函数  </span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数  </span></span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 派生类 Circle  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a circle.\n&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printRadius</span><span class="params">()</span> <span class="type">const</span> </span>&#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Circle radius...\n&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 派生类 Rectangle  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a rectangle.\n&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printWidth</span><span class="params">()</span> <span class="type">const</span> </span>&#123;  </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Rectangle width...\n&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drawAndPrint</span><span class="params">(<span class="type">const</span> Shape* shapes[], <span class="type">int</span> size)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;  </span><br><span class="line">        Circle* circle = <span class="built_in">dynamic_cast</span>&lt;Circle*&gt;(shapes[i]);  </span><br><span class="line">        Rectangle* rectangle = <span class="built_in">dynamic_cast</span>&lt;Rectangle*&gt;(shapes[i]);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (circle) &#123;  </span><br><span class="line">            circle-&gt;<span class="built_in">draw</span>();  </span><br><span class="line">            circle-&gt;<span class="built_in">printRadius</span>();  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rectangle) &#123;  </span><br><span class="line">            rectangle-&gt;<span class="built_in">draw</span>();  </span><br><span class="line">            rectangle-&gt;<span class="built_in">printWidth</span>();  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Unknown shape type.\n&quot;</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><code>dynamic_cast</code> 是类型安全的，因为它在运行时检查转换的有效性。它主要用于类层次结构中的向下和侧向转换。</li><li><code>static_cast</code> 是类型不安全的，因为它不进行运行时检查。它适用于多种情况，包括向上转换和基本数据类型之间的转换。</li></ul><p>在类层次结构中，当你知道转换是安全的，或者当你需要转换到基类类型时，通常使用 <code>static_cast</code>。当你需要执行可能不安全的向下或侧向转换时，应该使用 <code>dynamic_cast</code> 并检查转换是否成功。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>左值and右值.md</title>
      <link href="/2024/02/04/%E5%B7%A6%E5%80%BCand%E5%8F%B3%E5%80%BC-md/"/>
      <url>/2024/02/04/%E5%B7%A6%E5%80%BCand%E5%8F%B3%E5%80%BC-md/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h4 id="左值"><a href="#左值" class="headerlink" title="左值"></a>左值</h4><p>左值，即“可左值”，是指在赋值等号（&#x3D;）左边，表示存储在计算机内存的对象，可寻址，相当于 <code>地址值</code>。也就是说，它们有明确的存储位置，可以被赋予一个新的值。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;  <span class="comment">// a 是一个左值，可以被赋值</span></span><br></pre></td></tr></table></figure><p>一个返回值例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_val</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br></pre></td></tr></table></figure><p>在这里，<code>x</code> 是一个在函数外部定义的变量，它在函数 <code>get_val</code> 之外有存储位置。当调用 <code>get_val()</code> 时，实际上是请求返回 <code>x</code> 的当前值。这个返回值（即 <code>x</code> 的值）可以被赋给另一个变量，因此它是一个左值。</p><p>重要的是要理解 <code>return x;</code> 并不返回 <code>x</code> 的地址或引用，而是返回它的值。尽管 <code>x</code> 在函数内部是未定义的（因为它不是函数的作用域），但 <code>return x;</code> 实际上是在说“请获取 <code>x</code> 的当前值并返回它”。</p><p>所以，函数 <code>get_val</code> 返回的是 <code>x</code> 的值的副本，这个副本是左值，因为它代表了一个可以被赋值的对象。</p><h4 id="右值"><a href="#右值" class="headerlink" title="右值"></a>右值</h4><p>右值，即“可右值”，是临时创建的对象，通常出现在赋值符号“&#x3D;”的右边，如字面量或临时对象，是<code>数据值</code>。右值不能被赋值给其他变量，但可以通过使用特殊的操作符（如 std::move）来将其内容转移到其他对象中。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b = <span class="number">20</span>;  <span class="comment">// b 是一个左值，可以被赋值</span></span><br><span class="line"><span class="type">int</span> c = b;   <span class="comment">// c 接收 b 的值</span></span><br></pre></td></tr></table></figure><p>在某些情况下，可以通过右值引用和移动语义将右值的内容转移到另一个对象中，这是一种优化性能的技术。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v2 = std::<span class="built_in">move</span>(v1);  <span class="comment">// v1 现在是一个空容器，v2 获得 v1 的内容</span></span><br></pre></td></tr></table></figure><p><code>v1</code> 是一个左值引用，而 <code>std::move(v1)</code> 返回一个右值引用，允许将 <code>v1</code> 的内容移动到 <code>v2</code> 中。</p><p><code>总之，返回值是左值还是右值取决于返回对象的性质和上下文。如果返回的对象可以被赋值，则是左值；如果返回的对象只是数据值，不能被赋值，则是右值。</code></p><h4 id="亡值"><a href="#亡值" class="headerlink" title="亡值"></a>亡值</h4><p>亡值通常指的是那些在其生命周期的最后一步中可以被安全移动的对象。在C++中，亡值通常与<code>std::move</code>和右值引用一起使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="function">std::string <span class="title">createString</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    std::string str = <span class="string">&quot;Hello, World!&quot;</span>;  </span><br><span class="line">    <span class="comment">// 这里没有使用 std::move，因为返回类型不是右值引用  </span></span><br><span class="line">    <span class="comment">// 局部变量会在函数返回时被销毁，但我们返回的是它的副本  </span></span><br><span class="line">    <span class="keyword">return</span> str;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 使用 std::move 创建一个亡值  </span></span><br><span class="line">    std::string str = <span class="built_in">createString</span>();  </span><br><span class="line">    std::string str2 = std::<span class="built_in">move</span>(str); <span class="comment">// 将 str 转换为亡值，并将其资源移动到 str2  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 注意：此时 str 处于有效但未定义的状态，不应再使用  </span></span><br><span class="line">    std::cout &lt;&lt; str2 &lt;&lt; std::endl; <span class="comment">// 输出 &quot;Hello, World!&quot;  </span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; str &lt;&lt; std::endl; // 这行代码不安全，因为 str 的内容已被移动  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>createString</code> 函数返回一个<code>std::string</code>类型的对象，这是一个左值。然后，在<code>main</code>函数中，我们使用<code>std::move</code>将<code>str</code>转换为亡值，并将其资源移动到<code>str2</code>中。在资源移动之后，<code>str</code>处于有效但未定义的状态，这意味着它不再包含原来的字符串，而且不应该再被使用。</p><p>需要注意的是，虽然<code>std::move</code>创建了一个亡值，但在实际编程中，通常不会将<code>std::move</code>应用于局部变量，除非确实需要这样做，并且清楚地知道之后不会再次使用该变量。这是因为移动语义通常用于优化性能，但也需要谨慎处理以避免引入错误。</p><p>此外，<code>createString</code>函数中的返回值优化（RVO）或命名返回值优化（NRVO）通常会导致没有实际的复制或移动操作发生，编译器会优化掉这个步骤。因此，在实际中，你可能不会看到像这个例子中那样明确的资源移动。</p><img src="/2024/02/04/%E5%B7%A6%E5%80%BCand%E5%8F%B3%E5%80%BC-md/PixPin_2024-02-05_12-50-58.png" class=""><p>表达式首先被分为了泛左值（glvalue）和右值（rvalue），其中泛左值被进一步划分为左值和将亡值，右值又被划分为将亡值和纯右值。理解这些概念的关键在于泛左值、纯右值和将亡值。</p><p>1.所谓泛左值是指一个通过评估能够确定对象、位域或函数的标识的表达式。简单来说，它确定了对象或者函数的标识（具名对象）。</p><p>2.而纯右值是指一个通过评估能够用于初始化对象和位域，或者能够计算运算符操作数的值的表达式。</p><p>3.将亡值属于泛左值的一种，它表示资源可以被重用的对象和位域，通常这是因为它们接近其生命周期的末尾，此外也可能是经过右值引用的转换产生的。</p><p>从<code>本质</code>上说产生将亡值的途径有两种:</p><p>第一种是使用类型转换将泛左值转换为该类型的右值引用。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_cast</span>&lt;BigMemoryPool&amp;&amp;&gt;(my_pool)</span><br></pre></td></tr></table></figure><p>第二种在C++17标准中引入，我们称它为临时量实质化，指的是纯右值转换到临时对象的过程。每当纯右值出现在一个需要泛左值的地方时，临时量实质化都会发生，也就是说都会创建一个临时对象并且使用纯右值对其进行初始化，这也符合纯右值的概念，而这里的临时对象就是一个将亡值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> b = <span class="built_in">X</span>().a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，X()是一个纯右值，访问其成员变量a却需要一个泛左值，所以这里会发生一次临时量实质化，将x0转换为将亡值，最后再访问其成员变量a。</p><h4 id="右值转化为左值"><a href="#右值转化为左值" class="headerlink" title="右值转化为左值"></a>右值转化为左值</h4><p>如果想完成将右值引用绑定到左值这个“壮举”还是有办法的。在C++11标准中可以在不创建临时值的情况下显式地将左值通过staticcast转换为将亡值，通过值类别的内容我们知道将亡值属于右值，所以可以被右值引用绑定。值得注意的是，由于转换的并不是右值，因此它依然有着和转换之前相同的生命周期和内存地址，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> &amp;&amp;k = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&amp;&amp;&gt;(i);</span><br></pre></td></tr></table></figure><h4 id="引用构造器"><a href="#引用构造器" class="headerlink" title="引用构造器"></a>引用构造器</h4><p>一个使用引用构造器和不使用引用构造器示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> width;</span><br><span class="line">    <span class="type">double</span> height;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 使用引用构造器</span></span><br><span class="line">    <span class="built_in">Rectangle</span>(<span class="type">const</span> <span class="type">double</span>&amp; w, <span class="type">const</span> <span class="type">double</span>&amp; h) : <span class="built_in">width</span>(w), <span class="built_in">height</span>(h) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Rectangle constructor called with width: &quot;</span> &lt;&lt; width &lt;&lt; <span class="string">&quot; and height: &quot;</span> &lt;&lt; height &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getArea</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> width * height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> base;</span><br><span class="line">    <span class="type">double</span> height;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 不使用引用构造器，使用赋值操作符</span></span><br><span class="line">    <span class="built_in">Triangle</span>(<span class="type">double</span> b, <span class="type">double</span> h) &#123;</span><br><span class="line">        base = b;</span><br><span class="line">        height = h;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Triangle constructor called with base: &quot;</span> &lt;&lt; base &lt;&lt; <span class="string">&quot; and height: &quot;</span> &lt;&lt; height &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getArea</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * base * height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用引用构造器创建Rectangle对象</span></span><br><span class="line">    <span class="function">Rectangle <span class="title">rect</span><span class="params">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Rectangle area: &quot;</span> &lt;&lt; rect.<span class="built_in">getArea</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不使用引用构造器创建Triangle对象，使用赋值操作符设置字段值</span></span><br><span class="line">    <span class="function">Triangle <span class="title">tri</span><span class="params">(<span class="number">5.0</span>, <span class="number">3.0</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Triangle area: &quot;</span> &lt;&lt; tri.<span class="built_in">getArea</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Rectangle</code>类使用了引用构造器来初始化<code>width</code>和<code>height</code>字段。在创建<code>Rectangle</code>对象时，直接通过参数传递值给构造器，然后使用初始化列表将参数的值赋给字段。因此，<code>width</code>和<code>height</code>字段在对象创建时就被正确地初始化了。<code>Rectangle</code>的构造函数输出了一条消息，表明构造器被调用了，并显示传递给构造器的参数值。然后，可以通过调用<code>getArea()</code>函数来获取矩形的面积。</p><p><code>Triangle</code>类没有使用引用构造器来初始化字段。在创建<code>Triangle</code>对象时，通过赋值操作符将参数的值赋给字段。因此，在对象创建后，我们需要手动设置<code>base</code>和<code>height</code>字段的值。与<code>Rectangle</code>一样，<code>Triangle</code>的构造函数也输出了一条消息，表明构造器被调用了，并显示传递给构造器的参数值。然后，我们可以通过调用<code>getArea()</code>函数来获取三角形的面积。</p><h5 id="引用构造器和初始化列表的区别"><a href="#引用构造器和初始化列表的区别" class="headerlink" title="引用构造器和初始化列表的区别"></a>引用构造器和初始化列表的区别</h5><p><code>Triangle(double b, double h):base(b),height(h)</code>这种构造函数的初始化列表方式与引用构造器在功能上是类似的，它们都可以用于在创建对象时初始化对象的字段。</p><p>引用构造器和初始化列表方式都可以减少内存分配和复制的开销，因为对象的字段在构造时直接被初始化，<code>不需要</code>进行额外的赋值操作。它们都可以提供更好的性能和异常安全性。</p><p>但是，它们之间还是有一些细微的差别：</p><ol><li><strong>语法</strong>：引用构造器使用<code>const reference</code>来接收参数，而初始化列表方式使用参数列表后面的冒号<code>:</code>和字段名来进行初始化。</li><li><strong>灵活性</strong>：引用构造器更灵活，因为它可以用于任何类型，包括非POD（Plain Old Data）类型，如类类型。而初始化列表方式主要用于POD类型，因为POD类型的构造函数和析构函数是按照声明的顺序调用的，所以可以使用初始化列表方式来初始化它们的字段。</li><li><strong>参数个数</strong>：引用构造器的参数个数必须与类的字段个数一致，而初始化列表方式的参数个数可以少于类的字段个数，只需要列出需要初始化的字段即可。</li><li><strong>异常安全性</strong>：如果使用引用构造器，并且在构造过程中发生异常，已经分配的内存不会被释放，避免了资源泄漏。而使用初始化列表方式时，如果发生异常，已经分配的内存可能会被正确释放。</li></ol><p>使用引用构造器和初始化列表方式都可以在创建对象时初始化对象的字段。</p><h4 id="移动构造器"><a href="#移动构造器" class="headerlink" title="移动构造器"></a>移动构造器</h4><p>移动构造函数是一种特殊的构造函数，用于在对象移动语义中构造和初始化对象。它是C++11引入的新特性之一，用于优化性能和减少不必要的拷贝操作。</p><p>移动构造函数的主要特点是它会将资源从另一个对象“移动”到新创建的对象中，而不是像拷贝构造函数那样进行深拷贝。这样可以避免不必要的资源复制和释放操作，提高性能。</p><p>移动构造函数的定义通常使用“&amp;&amp;”符号来表示它接受右值引用作为参数。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span>* ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span>* p) : <span class="built_in">ptr</span>(p) &#123;&#125; <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">ptr</span>(other.ptr) &#123;<span class="comment">//使用noexcept说明符限制该函数。这样当函数抛出异常的时候，程序不会再继续执行而是调用std::terminate中止执行以免造成其他不良影响。</span></span><br><span class="line">        other.ptr = <span class="literal">nullptr</span>; <span class="comment">// 移动构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>移动构造函数接受一个右值引用作为参数<code>other</code>，并通过将<code>other.ptr</code>赋值给<code>ptr</code>来移动资源。同时，为了避免异常安全问题，在移动构造函数中显式地将<code>other.ptr</code>设置为<code>nullptr</code>，以避免悬挂指针等问题。</p><p>使用移动构造函数可以显著提高性能，特别是对于大型对象和资源密集型对象。通过避免不必要的拷贝操作，移动构造函数可以减少内存分配和释放的开销，提高程序的执行效率。</p><h4 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>&amp;&amp; i)</span></span>&#123;&#125;      <span class="comment">//i为右值引用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bar</span><span class="params">(T&amp;&amp; t)</span></span>&#123;&#125;      <span class="comment">//t为万能引用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_val</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">5</span>;&#125;</span><br><span class="line"><span class="type">int</span> &amp;&amp;x = <span class="built_in">get_val</span>();      <span class="comment">//x为右值引用</span></span><br><span class="line"><span class="keyword">auto</span> &amp;&amp;y = <span class="built_in">get_val</span>();      <span class="comment">//y为万能引用</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，函数foo的形参和变量x是右值引用，而函数模板的形参t和变量y则是万能引用。我们知道右值引用只能绑定一个右值，但是万能引用既可以绑定左值也可以绑定右值，甚至const和volatile的值都可以绑定，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> j = <span class="number">11</span>;</span><br><span class="line"><span class="built_in">bar</span>(i);</span><br><span class="line"><span class="built_in">bar</span>(j);</span><br><span class="line"><span class="built_in">bar</span>(<span class="built_in">get_val</span>());</span><br><span class="line"><span class="keyword">auto</span> &amp;&amp;x = i;</span><br><span class="line"><span class="keyword">auto</span> &amp;&amp;y = j;</span><br><span class="line"><span class="keyword">auto</span> &amp;&amp;z = <span class="built_in">get_val</span>();</span><br></pre></td></tr></table></figure><p>所谓的万能引1用是因为发生了类型推导，在T&amp;&amp;和auto&amp;&amp;的初始化过程中都会发生类型的推导，如果已经有一个确定的类型，比如int&amp;&amp;，则是右值引用。在这个推导过程中，初始化的源对象如果是一个左值，则目标对象会推导出左值引用；反之如果源对象是一个右值则会推导出右值引用，不过无论如何都会是一个引用类型。</p><img src="/2024/02/04/%E5%B7%A6%E5%80%BCand%E5%8F%B3%E5%80%BC-md/PixPin_2024-02-05_15-51-34.png" class=""><h4 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_type</span><span class="params">(T t)</span></span>&#123;<span class="comment">//传入左值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">typeid</span>(t).<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">normal_forwarding</span><span class="params">(T &amp;&amp;t)</span></span>&#123;<span class="comment">//const T &amp;t//折叠后还是左值</span></span><br><span class="line">    <span class="built_in">show_type</span>(<span class="built_in">static_cast</span>&lt;T&amp;&amp;&gt;(t));<span class="comment">//左值和模板右值引用折叠后还是左值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::string <span class="title">get_string</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hi&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::string s = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="built_in">normal_forwarding</span>(s);<span class="comment">//左值传入</span></span><br><span class="line">    <span class="built_in">normal_forwarding</span>(<span class="built_in">get_string</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 左右值 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数记录.md</title>
      <link href="/2024/01/21/%E5%87%BD%E6%95%B0%E8%AE%B0%E5%BD%95-md/"/>
      <url>/2024/01/21/%E5%87%BD%E6%95%B0%E8%AE%B0%E5%BD%95-md/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h4 id="cctype"><a href="#cctype" class="headerlink" title="cctype"></a>cctype</h4><p>transfrom + lambda</p><ol><li><code>result.begin()</code>: 这是输出范围的起始迭代器。是将转换后的元素写入的起始位置。</li><li><code>result.end()</code>: 这是输出范围的结束迭代器。是不应再写入数据的位置。</li><li><code>result.begin()</code>: 这是输入范围的起始迭代器。是从哪里开始获取数据来进行转换的。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">transform</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>(), result.<span class="built_in">begin</span>(),   </span><br><span class="line">    [](<span class="type">unsigned</span> <span class="type">char</span> c)&#123; <span class="keyword">return</span> std::<span class="built_in">tolower</span>(c); &#125; <span class="comment">// 使用tolower函数将所有字符转换为小写    </span></span><br><span class="line">);   <span class="comment">// 使用toupper函数将所有字符转换为大写</span></span><br></pre></td></tr></table></figure><p>isalpha()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> judge = <span class="built_in">isalpha</span>(<span class="string">&#x27;a&#x27;</span>);<span class="comment">//----&gt;true</span></span><br><span class="line"><span class="type">bool</span> judge = <span class="built_in">isalpha</span>(<span class="string">&#x27;A&#x27;</span>);<span class="comment">//----&gt;true</span></span><br><span class="line"><span class="type">bool</span> judge = <span class="built_in">isalpha</span>(<span class="string">&#x27;1&#x27;</span>);<span class="comment">//----&gt;false</span></span><br></pre></td></tr></table></figure><p>isalnum()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> judge = <span class="built_in">isalnum</span>(<span class="string">&#x27;a&#x27;</span>);<span class="comment">//----&gt;true</span></span><br><span class="line"><span class="type">bool</span> judge = <span class="built_in">isalnum</span>(<span class="string">&#x27;A&#x27;</span>);<span class="comment">//----&gt;true</span></span><br><span class="line"><span class="type">bool</span> judge = <span class="built_in">isalnum</span>(<span class="string">&#x27;1&#x27;</span>);<span class="comment">//----&gt;true</span></span><br></pre></td></tr></table></figure><h4 id="utility"><a href="#utility" class="headerlink" title="utility"></a>utility</h4><p>std::forward: 该函数用于实现完美转发，它接受两个参数，第一个参数是要转发的参数，第二个参数是一个布尔值，指示是否应该以左值或右值转发参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp; t)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp;&amp; t)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>std::move: 该函数用于将一个对象转换为右值引用，从而可以将其移动到另一个对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">move</span><span class="params">(T&amp; t)</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>std::exchange: 该函数用于交换两个变量的值。它接受两个参数，第一个参数是要交换的变量，第二个参数是用于交换的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">exchange</span><span class="params">(T&amp; obj, T&amp;&amp; val)</span></span>;</span><br></pre></td></tr></table></figure><p>std::make_pair: 该函数用于创建一个std::pair对象，它接受两个参数，分别表示<code>pair</code>的两个元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1, <span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function">std::pair&lt;V1,V2&gt; <span class="title">make_pair</span><span class="params">(T1&amp;&amp; x, T2&amp;&amp; y)</span></span>;</span><br></pre></td></tr></table></figure><p>std::tie: 该函数用于将多个对象的值存储到一个tuple中。它接受一个可变参数列表，每个参数都是要存储的对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;</span></span><br><span class="line"><span class="function">tuple&lt;Args...&gt; <span class="title">tie</span><span class="params">(Args&amp;... args)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h4><p>is_sorted()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="type">bool</span> judge = <span class="built_in">is_sorted</span>();<span class="comment">//----&gt;true</span></span><br></pre></td></tr></table></figure><h4 id="numeric"><a href="#numeric" class="headerlink" title="numeric"></a>numeric</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; nums1 = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="type">int</span> sum = <span class="built_in">accumulate</span>(nums1.<span class="built_in">begin</span>(), nums1.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; nums2 = &#123;<span class="string">&quot;abcde&quot;</span>, <span class="string">&quot;fghijk&quot;</span>, <span class="string">&quot;lmnopq&quot;</span>&#125;;</span><br><span class="line">string str = <span class="built_in">accumulate</span>(nums2.<span class="built_in">begin</span>(), nums2.<span class="built_in">end</span>(), <span class="built_in">string</span>());</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找.md</title>
      <link href="/2024/01/18/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-md/"/>
      <url>/2024/01/18/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-md/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>二分查找算法（Binary Search）是一种在有序数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是目标值，则搜索过程结束；如果目标值大于或小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且同样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。</p><p>数组有序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> x)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;  </span><br><span class="line">        <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;  </span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == x) &#123;  </span><br><span class="line">            <span class="keyword">return</span> mid;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &lt; x) &#123;  </span><br><span class="line">            l = mid + <span class="number">1</span>;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            r = mid - <span class="number">1</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 如果找不到目标值，则返回-1  </span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">40</span>&#125;;  </span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]);  </span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;  </span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">binarySearch</span>(arr, <span class="number">0</span>, n - <span class="number">1</span>, x);  </span><br><span class="line">    (result == <span class="number">-1</span>) ? cout &lt;&lt; <span class="string">&quot;Element is not present in array&quot;</span> : cout &lt;&lt; <span class="string">&quot;Element is present at index &quot;</span> &lt;&lt; result;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有序 + 旋转：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= nums[mid]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[n - <span class="number">1</span>]) &#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 搜索算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kmp.md</title>
      <link href="/2024/01/14/kmp-md/"/>
      <url>/2024/01/14/kmp-md/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>kmp算法：</p><p>KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt同时发现，因此人们称它为克努特-莫里斯-普拉特操作（简称KMP算法）。 KMP算法的关键是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是通过一个next()函数实现，函数本身包含了模式串的局部匹配信息。</p><p>KMP算法的主要思想是：在文本串（文章）中查找模式串（关键字）时，利用模式串和文本串中已经匹配的部分，跳过一些无用的比较，使文本串的标记指针不会回溯，模式串的标记指针移动。例如：文本串：abcaabce 模式串：abce，上面的文本串和模式串第一次比较时，由于索引为3的位置a和e不相同，假设文本串的索引i&#x3D;3，模式串的索引j&#x3D;3，kmp的思想是由于前面的abc已经匹配完成，我们从中可以知道里面没有a，所以此时我们的文本串中标记指针不变依然是i&#x3D;3，但是模式串的指针变化j&#x3D;0，这样可以省略一些无用的比较，所以我们需要研究模式串发现其中的规律。</p><p>此外，KMP算法利用模式串的最长的相同的前后缀进行移动，而主串不需要回溯，从而达到快速匹配的目的。例如：在箭头处发生不匹配时，找到箭头之前模式串子串的最长的相同的前后缀，为AB；然后把前缀AB移动到后缀AB的位置；再继续进行匹配，同理，发生不匹配时，找到箭头之前模式串子串的最长的相同的前后缀，为A；然后把前缀A移动到后缀A的位置，因为超出主串长度所以匹配失败。</p><p>c++函数实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">compute_prefix_function</span><span class="params">(std::string pattern)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = pattern.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">prefix</span><span class="params">(m, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; pattern[j] != pattern[i]) &#123;</span><br><span class="line">                j = prefix[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pattern[j] == pattern[i]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            prefix[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">kmp_search</span><span class="params">(std::string text, std::string pattern)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = text.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> m = pattern.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; pos;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; prefix = <span class="built_in">compute_prefix_function</span>(pattern);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; text[i] != pattern[j])</span><br><span class="line">                j = prefix[j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (text[i] == pattern[j])</span><br><span class="line">                j++;</span><br><span class="line">            <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">                pos.<span class="built_in">emplace_back</span>(i - j + <span class="number">1</span>);</span><br><span class="line">                j = prefix[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 学习使用记录函数C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cmake.md</title>
      <link href="/2024/01/09/cmake-md/"/>
      <url>/2024/01/09/cmake-md/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>生成build文件夹：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -B build</span><br></pre></td></tr></table></figure><p>生成二进制执行文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --build build</span><br></pre></td></tr></table></figure><p>执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build/Debug/Hello.exe</span><br></pre></td></tr></table></figure><p>在linux中使用cmake</p><p>安装</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install cmake</span><br></pre></td></tr></table></figure><p>检测</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake --version</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir ch1_1_hello</span><br><span class="line">code ch1_1_hello</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> cmake使用基本命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程函数.md</title>
      <link href="/2023/11/25/%E7%BA%BF%E7%A8%8B%E5%87%BD%E6%95%B0-md/"/>
      <url>/2023/11/25/%E7%BA%BF%E7%A8%8B%E5%87%BD%E6%95%B0-md/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h4 id="joinable"><a href="#joinable" class="headerlink" title="joinable()"></a>joinable()</h4><p><code>joinable()</code> 是 C++ 中的一个函数，用于检查一个线程是否可以被加入（joined）。如果一个线程是可加入的，那么就可以通过 <code>join()</code> 或 <code>detach()</code> 函数来等待它结束。如果一个线程已经被 <code>join()</code> 或 <code>detach()</code>，那么再次调用 <code>joinable()</code> 会返回 false。</p><p>在 <code>std::thread</code> 对象上调用 <code>joinable()</code> 可以返回一个布尔值，表示该线程是否可以被加入。如果返回 true，则该线程可以被加入；如果返回 false，则该线程已经结束或者尚未被启动。</p><p>以下是 <code>joinable()</code> 的一个简单示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(foo)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (t.<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们创建了一个名为 <code>t</code> 的新线程，然后检查它是否可以被加入。如果可以，我们就调用 <code>join()</code> 等待它结束。</p><h4 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h4><p>在C++中，<code>std::join</code>函数是用于等待一个线程结束的函数，可以使用C++的多线程库（例如<code>std::thread</code>）来创建和管理多个线程，并使用<code>std::join</code>函数来等待这些线程的结束。</p><p>使用<code>std::thread</code>和<code>std::join</code>函数的多线程示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from thread!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(threadFunction)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (t.<span class="built_in">joinable</span>()) &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;   </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello from main thread!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/11/25/%E7%BA%BF%E7%A8%8B%E5%87%BD%E6%95%B0-md/Snipaste_2023-11-25_13-37-41.png" class="" title="Snipaste_2023-11-25_13-37-41"><p>我们创建了一个新的线程<code>t</code>，并将它绑定到一个名为<code>threadFunction</code>的函数上。然后，使用<code>std::join</code>函数等待该线程的结束。注意，在调用<code>std::join</code>之前，我们必须先检查线程是否可加入（使用<code>joinable</code>函数）。如果线程已经终止，那么调用<code>std::join</code>将导致程序立即终止。最后，在主线程中打印一条消息。</p><p>由于线程的执行顺序是不确定的，因此输出顺序可能会有所不同。</p><h4 id="detach"><a href="#detach" class="headerlink" title="detach()"></a>detach()</h4><p><code>detach()</code>函数用于将线程从主线程中分离出去，使其成为一个独立的线程。当一个线程被<code>detach()</code>后，它将不再与主线程关联，不会受到主线程的影响。具体来说，被<code>detach()</code>的线程会继续执行，直到其完成或发生异常退出。但是，被<code>detach()</code>的线程无法再被主线程控制或访问。</p><p>使用场景：</p><ol><li>在主线程结束时，将其他线程<code>detach()</code>可以确保这些线程能够继续执行，而不会受到主线程结束的影响。</li><li>在某些情况下，我们可能希望将一些任务交给另一个线程去执行，但是这些任务完成后并不需要主线程进行任何操作。这时，可以使用<code>detach()</code>将该线程与主线程分离，让其在后台独立执行。</li></ol><p>需要注意的是，被<code>detach()</code>的线程在完成执行后会自动退出，但是其资源并不会被自动回收。如果需要手动回收资源，可以通过使用<code>join()</code>函数等待线程结束。</p><p><code>detach</code>函数在多线程中的示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">workerThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker thread finished&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(workerThread)</span></span>;</span><br><span class="line">    </span><br><span class="line">    t.<span class="built_in">detach</span>(); <span class="comment">// 将线程与当前对象分离</span></span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main thread is running&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在主线程中执行其他任务</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">2</span>));</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Main thread finished&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/11/25/%E7%BA%BF%E7%A8%8B%E5%87%BD%E6%95%B0-md/Snipaste_2023-11-25_13-36-06.png" class="" title="Snipaste_2023-11-25_13-36-06"><p>在这个示例中，创建了一个名为<code>t</code>的线程对象，并将其绑定到名为<code>workerThread</code>的函数上。然后，使用<code>detach</code>函数将线程与当前对象分离，使其在后台运行。接着，在主线程中执行其他任务。当主线程执行完毕后，即使后台线程仍在运行，程序也会正常结束。</p><p><code>注意共享空间的使用配合 detach() 函数可能会导致崩溃。</code></p><p><code>并且不能和 join() 函数一起使用，只能使用其中一个</code></p><h4 id="ref（）"><a href="#ref（）" class="headerlink" title="ref（）"></a>ref（）</h4>]]></content>
      
      
      
        <tags>
            
            <tag> C++多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程使用.md</title>
      <link href="/2023/11/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8-md/"/>
      <url>/2023/11/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8-md/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>多线程（Multithreading）是指在一个程序中<strong>同时运行</strong>多个线程，每个线程都可以独立执行不同的任务或代码片段，从而使程序具有并发执行的能力。</p><p>头文件：<thread></p><h4 id="多线程与单线程的区别"><a href="#多线程与单线程的区别" class="headerlink" title="多线程与单线程的区别"></a>多线程与单线程的区别</h4><p>主要体现在以下几个方面：</p><ol><li><strong>地址空间和资源</strong>：同一进程的线程之间共享本进程的地址空间和资源，而进程之间则是独立的。</li><li><strong>通信方式</strong>：同一进程内的线程之间可以直接读写彼此的数据空间，这使得线程间通信非常方便。但进程通信时必须通过操作系统来进行，相对要复杂得多。</li><li><strong>运行开销</strong>：创建和撤销一个进程需要保存寄存器、栈信息以及进行资源分配和回收等操作，开销较大。而线程的创建和撤销只需保存寄存器和栈信息，开销较小。</li><li><strong>执行过程</strong>：每个独立的进程都有一个程序运行的入口、顺序执行序列和程序入口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li><li><strong>调度</strong>：线程是处理器调度的基本单位，但是进程不是。</li><li><strong>开销</strong>：创建和撤销一个进程需要保存寄存器、栈信息以及进行资源分配和回收等操作，开销较大。而线程的创建和撤销只需保存寄存器和栈信息，开销较小。</li></ol><p>​多线程和多进程虽然都是实现并发执行的技术，但在地址空间、资源拥有、通信方式、运行开销、执行过程以及调度等方面存在明显的差异。</p><h4 id="多线程适用场景"><a href="#多线程适用场景" class="headerlink" title="多线程适用场景"></a>多线程适用场景</h4><p>多线程在编程中适合解决以下问题：</p><ol><li><strong>处理大量并发任务</strong>：当需要处理大量并发任务时，例如在服务器端处理大量客户端请求，多线程可以提高程序的响应速度和吞吐量。</li><li><strong>充分利用CPU资源</strong>：多线程可以同时执行多个任务，充分利用计算机的CPU资源，提高程序的运行效率。</li><li><strong>实现并行计算</strong>：多线程可以用于实现并行计算，将一个任务分解成多个子任务，并在多个处理器上同时执行，提高计算速度和效率。</li><li><strong>提高用户体验</strong>：在图形界面、游戏、多媒体处理等应用中，多线程可以提高程序的流畅度和响应速度，从而提高用户体验。</li><li><strong>实现分布式计算</strong>：多线程可以用于实现分布式计算，将任务分配给多个计算机节点，提高计算效率和可靠性。</li><li><strong>处理I&#x2F;O密集型任务</strong>：多线程可以用于处理I&#x2F;O密集型任务，例如网络通信、文件读写等，提高程序的响应速度和吞吐量。</li><li><strong>实现高并发程序设计</strong>：多线程可以用于实现高并发程序设计，提高程序的并发执行能力和响应速度。</li></ol><p>​多线程在编程中适合解决各种并发任务的处理、提高程序的运行效率和响应速度、充分利用计算机资源、提高用户体验等问题。</p><h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//程序运行起来生成一个进程，该进程所属的主线程开始自动运行</span></span><br><span class="line">    <span class="comment">//实际上这个是主线程在执行，主线程从 main() 函数返回，整个进程执行完毕</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello World！&quot;</span>&lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myprint</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;我的线程开始执行了！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//…………</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;我的线程结束执行了！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//主线程从 main() 函数开始执行，自己创建的线程也需要有一个(初始函数)</span></span><br><span class="line">    <span class="comment">//一旦初始函数运行完毕，代表着线程运行也结束了</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//整个进程是否执行完毕的标志是主线程是否执行完毕</span></span><br><span class="line">    <span class="comment">//若此时有子线程还未执行完毕，将会被操作系统强行终止</span></span><br><span class="line">    <span class="comment">//想要保持子线程(创教的线程)运行状态，就要让主线程不要运行完毕</span></span><br><span class="line">    <span class="function">thread <span class="title">myobj</span><span class="params">(myprint)</span></span>;      <span class="comment">//函数作为可调用对象作为线程入口</span></span><br><span class="line">    myobj.<span class="built_in">join</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello World!&quot;</span> &lt;&lt; endl; </span><br><span class="line">    <span class="comment">//本次执行有两个线程</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/11/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8-md/Snipaste_2023-11-25_13-00-27.png" class="" title="Snipaste_2023-11-25_13-00-27"><h5 id="用类来创建线程"><a href="#用类来创建线程" class="headerlink" title="用类来创建线程"></a>用类来创建线程</h5><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span>&amp; i) :<span class="built_in">m_i</span>(i) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span>      <span class="comment">//重载 ()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;我的线程operator()开始执行了！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">//…………</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;m_i = &quot;</span> &lt;&lt; m_i &lt;&lt; endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;我的线程operator()结束执行了！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">myobj</span><span class="params">(a)</span></span>;      <span class="comment">//将类对象作为一个可调用对象，这个对象是被复制到线程中去的</span></span><br><span class="line">    myobj.<span class="built_in">join</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello World!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/11/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8-md/Snipaste_2023-11-25_14-17-31.png" class="" title="Snipaste_2023-11-25_14-17-31"><p>需要注意的是当我们使用<code>detach()</code>时，要注意资源被回收后，如果此时我们再去使用相关资源会产生不可预料的后果。</p><p>比如：<code>int num = 6; A a(num);</code>并且在上面的构造函数中使用的是引用，当 num 被回收后再去调用重载中的m_i就会出现问题。</p><blockquote><p>但是我们传入A类的对象作为参数，其实是将该类对象复制拷贝到线程中去执行的，所以当主线程执行完毕后，被拷贝出来的对象依然是存在的。（如果是引用传递则会出现上面的问题）</p></blockquote><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> i) :<span class="built_in">m_i</span>(i)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;A()构造函数被执行&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; 线程id:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">A</span>(<span class="type">const</span> A&amp; a) :<span class="built_in">m_i</span>(a.m_i)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;A()拷贝构造函数被执行&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; 线程id:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">A</span>()</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;A()析构函数被执行&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; 线程id:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;我的线程operator()开始执行了！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;m_i的值为：&quot;</span> &lt;&lt; m_i &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;[子线程operator()执行]&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; 线程id:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;我的线程operator()结束执行了！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span>      <span class="comment">//重载 ()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;我的线程operator()开始执行了！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">//…………</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m_i = &quot;</span> &lt;&lt; m_i &lt;&lt; endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;我的线程operator()结束执行了！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;主线程id = &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">myobj</span><span class="params">(a)</span></span>;      <span class="comment">//将类对象作为一个可调用对象</span></span><br><span class="line">myobj.<span class="built_in">join</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Hello World!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/11/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8-md/Snipaste_2023-11-27_13-22-33.png" class="" title="Snipaste_2023-11-27_13-22-33"><h5 id="用lambda表达式创建线程"><a href="#用lambda表达式创建线程" class="headerlink" title="用lambda表达式创建线程"></a>用lambda表达式创建线程</h5><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> mylamthread = []()<span class="comment">//lambda表达式的使用，用lambda表达式创建线程</span></span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;我的线程1开始执行&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;我的线程1执行结束&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">std::thread <span class="title">myobj</span><span class="params">(mylamthread)</span></span>;</span><br><span class="line"><span class="comment">//mytobj.detach();</span></span><br><span class="line">myobj.<span class="built_in">join</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello World!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/11/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8-md/Snipaste_2023-11-25_14-42-08.png" class="" title="Snipaste_2023-11-25_14-42-08"><h4 id="线程参数"><a href="#线程参数" class="headerlink" title="线程参数"></a>线程参数</h4><h5 id="传递临时对象作为线程参数"><a href="#传递临时对象作为线程参数" class="headerlink" title="传递临时对象作为线程参数"></a>传递临时对象作为线程参数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myprint</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; a, <span class="type">const</span> std::string&amp; buf)</span>      <span class="comment">//加const是为了接受右值</span></span></span><br><span class="line"><span class="function"><span class="comment">//虽然说这里是 &amp;a 但不是一个真引用，而是一个复制的值，实际为值传递（不推荐使用引用）</span></span></span><br><span class="line"><span class="function"><span class="comment">//即便使用detach()也是安全的</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//如果参数列表传入是指针（const char* buf）则一定会出现问题，此时为引用传递(不能使用)</span></span></span><br><span class="line"><span class="function"><span class="comment">//可以使用(const std::string &amp;buf)此时会产生一个临时对象，不会出现问题</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;a=&quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; &amp;a &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;buf[]=&quot;</span> &lt;&lt; buf.<span class="built_in">c_str</span>() &lt;&lt; std::endl;<span class="comment">//buf也可以</span></span><br><span class="line">std::cout &lt;&lt; &amp;buf &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;子线程myprint()的参数地址是:&quot;</span> &lt;&lt; &amp;buf &lt;&lt; <span class="string">&quot; 线程id:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;主线程id = &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="type">int</span> mvar = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span>&amp; mvary = mvar;</span><br><span class="line"><span class="type">char</span> mybuf[] = <span class="string">&quot;this is a test!&quot;</span>;   <span class="comment">//传入一个字符数组作为参数将会出现一个隐式类型转换-&gt;string</span></span><br><span class="line"><span class="function">std::thread <span class="title">myobj</span><span class="params">(myprint, mvar, std::string(mybuf))</span></span>;<span class="comment">//用mybuf构造一个临时string对象，保证线程中对象肯定有效</span></span><br><span class="line"><span class="comment">//避免出现当mybuf[]资源被回收之后才用去转 string 的情况</span></span><br><span class="line"><span class="comment">//在创建线程的同时构造临时对象的方法传递参数是可行的</span></span><br><span class="line">myobj.<span class="built_in">join</span>();</span><br><span class="line"><span class="comment">//myobj.detach();</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Hello World!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/11/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8-md/Snipaste_2023-11-27_13-19-26.png" class="" title="Snipaste_2023-11-27_13-19-26"><p>注意1：</p><p>传递int这种简单类型参数，建议使用值传递，不要使用引用，避免出现问题。</p><p>注意2：</p><p>如果传递类对象，要避免隐式类型转换。在创建函数这一行就构建出临时对象，然后在函数参数里用引用来接，否则系统会多调用一次构造函数。</p><h5 id="传递类对象、智能指针作为线程参数"><a href="#传递类对象、智能指针作为线程参数" class="headerlink" title="传递类对象、智能指针作为线程参数"></a>传递类对象、智能指针作为线程参数</h5><p>类对象做线程参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> i) :<span class="built_in">m_i</span>(i) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;A()构造函数被执行&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; 线程id:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">A</span>(<span class="type">const</span> A&amp; a) :<span class="built_in">m_i</span>(a.m_i) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;A()拷贝构造函数被执行&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; 线程id:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">A</span>() &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;A()析构函数被执行&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; 线程id:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">mutable</span> <span class="type">int</span> m_i;<span class="comment">//可更改成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myprint</span><span class="params">(<span class="type">const</span> A&amp; buf)</span> </span>&#123;</span><br><span class="line">buf.m_i = <span class="number">199</span>;      <span class="comment">//修改该值不会影响到main函数</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;子线程myprint的参数地址&quot;</span> &lt;&lt; &amp;buf &lt;&lt; <span class="string">&quot;  threadid = &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;主线程id = &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">myobj</span><span class="params">(myprint, a)</span></span>;<span class="comment">//将类对象作为线程参数</span></span><br><span class="line"><span class="comment">//std::thread myobj(myprint, std::ref(a));使用ref库函数传入函数时的形参就不用加const</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将真正的a的引用传递到函数myprint中去，不会调用拷贝构造函数，算是一个优化</span></span><br><span class="line"></span><br><span class="line">myobj.<span class="built_in">join</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Hello World!&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; a.m_i &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/11/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8-md/Snipaste_2023-11-27_13-17-09.png" class="" title="Snipaste_2023-11-27_13-17-09"><p>智能指针做线程参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myprint</span><span class="params">(unique_ptr&lt;<span class="type">int</span>&gt; ptr)</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;子线程myprint参数地址是&quot;</span> &lt;&lt; &amp;ptr &lt;&lt; <span class="string">&quot;线程id:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;主线程id = &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">100</span>))</span></span>;</span><br><span class="line"><span class="comment">//std::unique_ptr&lt;int&gt; ptr = std::make_unique&lt;int&gt;(100);//官方推荐使用</span></span><br><span class="line"><span class="function">std::thread <span class="title">mytobj</span><span class="params">(myprint, std::move(ptr))</span></span>;<span class="comment">//move()函数将指针值转到函数中的独占式指针中，并将原指针指为空</span></span><br><span class="line">mytobj.<span class="built_in">join</span>();<span class="comment">//一定要使用join（）</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Hello World!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/11/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8-md/Snipaste_2023-11-27_13-14-52.png" class="" title="Snipaste_2023-11-27_13-14-52"><h5 id="成员函数指针做线程参数"><a href="#成员函数指针做线程参数" class="headerlink" title="成员函数指针做线程参数"></a>成员函数指针做线程参数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> i) :<span class="built_in">m_i</span>(i) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;A()构造函数被执行&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; 线程id:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">A</span>(<span class="type">const</span> A&amp; a) :<span class="built_in">m_i</span>(a.m_i) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;A()拷贝构造函数被执行&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; 线程id:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">A</span>() &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;A()析构函数被执行&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; 线程id:&quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot;   m_i = &quot;</span> &lt;&lt; m_i &lt;&lt; std::endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;子线程入口函数work开始执行&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot;  thread_id = &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">mutable</span> <span class="type">int</span> m_i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//用成员函数做线程入口</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;主线程id = &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">mytobj</span><span class="params">(&amp;A::work,ref(a), <span class="number">99</span>)</span></span>;<span class="comment">//函数名，对象名，函数参数</span></span><br><span class="line">mytobj.<span class="built_in">join</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Hello World!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/11/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8-md/Snipaste_2023-11-27_13-11-42.png" class="" title="Snipaste_2023-11-27_13-11-42"><h4 id="同时创建多个线程"><a href="#同时创建多个线程" class="headerlink" title="同时创建多个线程"></a>同时创建多个线程</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myprint</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;myprint线程开始执行，子线程编号 = &quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot; 子线程id = &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建和等待多个线程</span></span><br><span class="line">std::vector&lt;std::thread&gt; mythreads;</span><br><span class="line"><span class="comment">//创建10个线程，线程入口函数统一使用myprint</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">mythreads.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>(myprint,i));<span class="comment">//创建并执行线程</span></span><br><span class="line">mythreads[i].<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//for (auto iter = mythreads.begin(); iter != mythreads.end(); ++iter)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//iter-&gt;join();//等待10个线程都返回</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Hello World!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/11/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8-md/Snipaste_2023-11-27_14-26-50.png" class="" title="Snipaste_2023-11-27_14-26-50"><h5 id="共享数据（只读）"><a href="#共享数据（只读）" class="headerlink" title="共享数据（只读）"></a>共享数据（只读）</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; arr = &#123; <span class="number">0</span>, <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;<span class="comment">//共享数据</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myprint</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;myprint线程开始执行，子线程编号 = &quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot; 子线程id = &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; 数组的数据：&quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; arr[<span class="number">1</span>] &lt;&lt; arr[<span class="number">2</span>] &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建和等待多个线程</span></span><br><span class="line">std::vector&lt;std::thread&gt; mythreads;</span><br><span class="line"><span class="comment">//创建10个线程，线程入口函数统一使用myprint</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">mythreads.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>(myprint,i));<span class="comment">//创建并执行线程</span></span><br><span class="line">mythreads[i].<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Hello World!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/11/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8-md/Snipaste_2023-11-27_14-30-43.png" class="" title="Snipaste_2023-11-27_14-30-43"><h5 id="共享数据（可读可写）"><a href="#共享数据（可读可写）" class="headerlink" title="共享数据（可读可写）"></a>共享数据（可读可写）</h5><p>当大于一个线程在写，其他线程在读时，如果代码没有特殊的处理，会导致程序崩溃。最简单的崩溃处理为读写分离。</p><p>错误示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InMessage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;InMessage()执行，插入一个元素 &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">msgRecvQueue.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OutMessage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!msgRecvQueue.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> command = msgRecvQueue.<span class="built_in">front</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;OutMessage()执行，取出一个元素&quot;</span> &lt;&lt; command &lt;&lt; std::endl;</span><br><span class="line">msgRecvQueue.<span class="built_in">pop_front</span>();</span><br><span class="line"><span class="comment">//…………</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;OutMessage()执行，但是目前消息队列为空&quot;</span> &lt;&lt; i&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;end&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::list&lt;<span class="type">int</span>&gt; msgRecvQueue;<span class="comment">//发送的信号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; arr = &#123; <span class="number">0</span>, <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;<span class="comment">//共享数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myprint</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;myprint线程开始执行，子线程编号 = &quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot; 子线程id = &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot; 数组的数据：&quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; arr[<span class="number">1</span>] &lt;&lt; arr[<span class="number">2</span>] &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">A a;</span><br><span class="line"><span class="function">std::thread <span class="title">mytobj</span><span class="params">(&amp;A::InMessage, &amp;a)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">mytobj1</span><span class="params">(&amp;A::OutMessage, &amp;a)</span></span>;</span><br><span class="line">mytobj.<span class="built_in">join</span>();</span><br><span class="line">mytobj1.<span class="built_in">join</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Hello World!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/11/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8-md/Snipaste_2023-11-27_15-06-22.png" class="" title="Snipaste_2023-11-27_15-06-22"><h4 id="互斥量（mutex）"><a href="#互斥量（mutex）" class="headerlink" title="互斥量（mutex）"></a>互斥量（mutex）</h4><h5 id="lock-and-unlock"><a href="#lock-and-unlock" class="headerlink" title="lock() and unlock()"></a>lock() and unlock()</h5><p>互斥量（Mutex）又称互斥信号量（Semaphore），是一个特殊的信号量。在多线程编程中，互斥量用于保护共享资源，防止多个线程同时访问共享资源。</p><p>任何时刻互斥量的状态只有两种，开锁和闭锁。当一个任务（线程）需要访问共享资源时，它必须先获得互斥量的所有权，即从闭锁状态变为开锁状态。当这个任务访问完共享资源后，它必须释放互斥量的所有权，即从开锁状态变为闭锁状态。其他任务只有在互斥量处于闭锁状态时才能获得它的所有权，从而保证对共享资源的独占式访问。</p><p>此外，互斥量还支持递归访问和防止优先级翻转的特性。递归访问指的是一个任务可以多次获得同一个互斥量的所有权而不被挂起，前提是这个任务每次获得所有权后能很快释放它。防止优先级翻转指的是在某些系统中，如果优先级较高的任务一直无法获得互斥量的所有权（例如，因为优先级较低的任务一直持有互斥量），可能会导致优先级较低的任务一直得不到运行，从而产生优先级翻转的问题。互斥量可以避免这种情况的发生。</p><p>lock()锁住一个mutex.lock();</p><p>lock()锁住两个以上lock(mutex1, mutex2);</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InMessage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;InMessage()执行，插入一个元素 &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">mymutex.<span class="built_in">lock</span>();</span><br><span class="line">msgRecvQueue.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">mymutex.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">OutMsg</span><span class="params">(<span class="type">int</span>&amp; command)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">mymutex.<span class="built_in">lock</span>();</span><br><span class="line"><span class="keyword">if</span> (!msgRecvQueue.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">command = msgRecvQueue.<span class="built_in">front</span>();<span class="comment">//返回第一个元素但不检查元素是否存在</span></span><br><span class="line">msgRecvQueue.<span class="built_in">pop_front</span>();<span class="comment">//移除第一个元素，但不返回</span></span><br><span class="line"><span class="comment">//处理数据........</span></span><br><span class="line">mymutex.<span class="built_in">unlock</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">mymutex.<span class="built_in">unlock</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OutMessage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> command = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">bool</span> result = <span class="built_in">OutMsg</span>(command);</span><br><span class="line"><span class="keyword">if</span> (result == <span class="literal">true</span>) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;OutMessage()执行，取出一个元素&quot;</span> &lt;&lt; command &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">//考虑数据处理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;OutMessage()执行，但是目前消息队列为空&quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;end&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::list&lt;<span class="type">int</span>&gt; msgRecvQueue;<span class="comment">//发送的信号</span></span><br><span class="line">std::mutex mymutex;<span class="comment">//创建一个互斥量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">A a;</span><br><span class="line"><span class="function">std::thread <span class="title">mytobj</span><span class="params">(&amp;A::InMessage, &amp;a)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">mytobj1</span><span class="params">(&amp;A::OutMessage, &amp;a)</span></span>;</span><br><span class="line">mytobj.<span class="built_in">join</span>();</span><br><span class="line">mytobj1.<span class="built_in">join</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Hello World!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/11/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8-md/Snipaste_2023-11-27_15-48-04.png" class="" title="Snipaste_2023-11-27_15-48-04"><h5 id="lock-guard"><a href="#lock-guard" class="headerlink" title="lock_guard()"></a>lock_guard()</h5><p><code>std::lock_guard</code>是C++的一种RAII（Resource Acquisition Is Initialization）包装类型，它是用于管理资源的锁定和解锁的。<code>std::lock_guard</code>对象在创建时自动锁定其管理的资源，而在其生命周期结束时自动解锁。这可以防止因异常或早期返回而导致的资源泄漏。</p><p>在多线程编程中，<code>std::lock_guard</code>经常用于保护共享数据，防止同时被多个线程访问和修改，造成数据不一致。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InMessage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;InMessage()执行，插入一个元素 &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#123;                                            <span class="comment">//可以通过这种（限定作用域）方式提前结束lock_guard</span></span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guardmu</span><span class="params">(mymutex)</span></span>;</span><br><span class="line">msgRecvQueue.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">OutMsg</span><span class="params">(<span class="type">int</span>&amp; command)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guardmu</span><span class="params">(mymutex)</span></span>;<span class="comment">//使用lock_guard()就不能使用lock() and unlock()</span></span><br><span class="line"><span class="keyword">if</span> (!msgRecvQueue.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">command = msgRecvQueue.<span class="built_in">front</span>();<span class="comment">//返回第一个元素但不检查元素是否存在</span></span><br><span class="line">msgRecvQueue.<span class="built_in">pop_front</span>();<span class="comment">//移除第一个元素，但不返回</span></span><br><span class="line"><span class="comment">//处理数据........</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于死锁问题的出现一定是使用了多个互斥量，想要避免就需要保证互斥量上锁顺序一致。</p><h5 id="lock-adopt"><a href="#lock-adopt" class="headerlink" title="lock_adopt"></a>lock_adopt</h5><p><code>std::adopt_lock</code>是C++17中引入的一种函数，它用于获取一个已经被其他线程持有的互斥锁（mutex）。当一个线程尝试获取已经被另一个线程持有的互斥锁时，通常会发生死锁，因为两个线程都会等待对方释放锁。而<code>std::adopt_lock</code>可以解决这个问题，它允许一个线程“领养”已经被另一个线程持有的锁。</p><p>使用<code>std::adopt_lock</code>时，一个线程可以调用该函数来尝试获取一个已经被其他线程持有的互斥锁。如果成功，该线程将获得锁并继续执行，而原来的持有锁的线程则可以继续持有锁，直到它主动释放锁。这种方式避免了死锁的发生，使得多个线程可以安全地共享互斥锁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InMessage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;InMessage()执行，插入一个元素 &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#123;   </span><br><span class="line">            std::<span class="built_in">lock</span>(mutex1, mutex2);       <span class="comment">//同时锁住两个                                  </span></span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guardmu</span><span class="params">(mutex1,std::adopt_lock)</span></span>;<span class="comment">//表示(标记)互斥量已经被lock</span></span><br><span class="line">         <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guardmu</span><span class="params">(mutex2,std::adopt_lock)</span></span>;</span><br><span class="line">msgRecvQueue.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="unique-lock"><a href="#unique-lock" class="headerlink" title="unique_lock"></a>unique_lock</h5><p><code>unique_lock</code>是一个类模板，它提供了比<code>lock_guard</code>更灵活的锁定和解锁互斥量（mutex）的功能。在日常开发工作中，<code>lock_guard</code>往往已经足够使用，但<code>unique_lock</code>的灵活性更好，能够适应更复杂的情况。</p><p><code>unique_lock</code>的主要作用是管理互斥量的锁定和解锁。与<code>lock_guard</code>在构造时锁定互斥量、析构时解锁互斥量不同，<code>unique_lock</code>提供了更灵活的控制，它可以在任何时候进行锁定和解锁操作。这使得<code>unique_lock</code>可以更好地应对一些复杂的情况，例如需要临时释放锁的情况。</p><p>此外，<code>unique_lock</code>还支持一些额外的特性，例如可以传递给其它函数或对象的锁。这在需要将锁传递给其他函数或对象时非常有用，可以避免重复锁定和解锁的操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InMessage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;InMessage()执行，插入一个元素 &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#123;   <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">guardmu</span><span class="params">(mymutex)</span></span>;<span class="comment">//不带参数      </span></span><br><span class="line">         </span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">guardmu</span><span class="params">(mymutex, std::adopt_lock)</span></span>;</span><br><span class="line">         <span class="comment">//第二个参数adopt_lock同样是起到一个标记的作用，表示互斥量已经被lock了，没有提前lock会报异常</span></span><br><span class="line">         </span><br><span class="line"><span class="comment">//std::unique_lock&lt;std::mutex&gt; guardmu(mymutex, std::try_to_lock);</span></span><br><span class="line">         <span class="comment">//第二个参数try_to_lock()，使用前不能lock（），try_to_lock()会自动尝试lock</span></span><br><span class="line">         <span class="comment">//if (guardmu.owns_lock()) </span></span><br><span class="line"><span class="comment">//拿到了锁</span></span><br><span class="line"><span class="comment">//………</span></span><br><span class="line"><span class="comment">//else</span></span><br><span class="line"><span class="comment">//没拿到</span></span><br><span class="line">         </span><br><span class="line">         <span class="comment">//std::unique_lock&lt;std::mutex&gt; guardmu(mymutex, std::defer_lock);</span></span><br><span class="line">         <span class="comment">//guardmu.lock();</span></span><br><span class="line">         <span class="comment">//不能提前加锁</span></span><br><span class="line">         </span><br><span class="line">msgRecvQueue.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="function">chrono::milliseconds <span class="title">sTime</span><span class="params">(<span class="number">2000</span>)</span></span>;<span class="comment">//毫秒为单位</span></span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(sTime);<span class="comment">//暂停</span></span><br></pre></td></tr></table></figure><h5 id="release"><a href="#release" class="headerlink" title="release()"></a>release()</h5><p><code>release()</code>函数通常用于释放资源，特别是在使用智能指针（如<code>std::unique_ptr</code>或<code>std::shared_ptr</code>）时。</p><p>对于<code>std::unique_ptr</code>，<code>release()</code>函数会释放它所指向的对象，并使<code>unique_ptr</code>再次成为空指针。这意味着，一旦你调用了<code>release()</code>，你就不能再访问或操作该<code>unique_ptr</code>指向的对象了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">guardmu</span><span class="params">(mymutex)</span></span>;<span class="comment">//绑定mutex</span></span><br><span class="line">std::mutex *ptx = guardmu.<span class="built_in">release</span>();<span class="comment">//将互斥量从绑定状态变成解绑状态，返回一个mutex类型的指针，此时需要自己手动unlock();</span></span><br><span class="line">ptx-&gt;<span class="built_in">unlock</span>();</span><br></pre></td></tr></table></figure><p><code>所有权转换</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">guardmu1</span><span class="params">(mymutex)</span></span>;</span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">guardmu2</span><span class="params">(std::move(guardmu1))</span></span>;</span><br><span class="line"><span class="comment">//左值变右值guardmu2指向mymutex</span></span><br></pre></td></tr></table></figure><h4 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex resource_mutex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCAS</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">MyCAS</span>() &#123;&#125;<span class="comment">//私有化构造函数，不能通过一般方法生成对象</span></span><br><span class="line"><span class="type">static</span> MyCAS* m_instance;<span class="comment">//静态成员变量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> MyCAS* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//提高效率</span></span><br><span class="line"><span class="keyword">if</span> (m_instance == <span class="literal">NULL</span>)<span class="comment">//双重锁定（双重检查）</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">mymutex</span><span class="params">(resource_mutex)</span></span>;<span class="comment">//自动加锁</span></span><br><span class="line"><span class="keyword">if</span> (m_instance == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">m_instance = <span class="keyword">new</span> <span class="built_in">MyCAS</span>();</span><br><span class="line"><span class="type">static</span> Clear c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clear</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~<span class="built_in">Clear</span>()</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span> (MyCAS::m_instance)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> MyCAS::m_instance;</span><br><span class="line">MyCAS::m_instance = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;测试&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类静态变量初始化</span></span><br><span class="line">MyCAS *MyCAS::m_instance = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程入口函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mythread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;我的线程开始执行了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">MyCAS* ptr = MyCAS::<span class="built_in">GetInstance</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;我的线程结束执行了&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyCAS* ptr = MyCAS::<span class="built_in">GetInstance</span>();</span><br><span class="line">ptr-&gt;<span class="built_in">func</span>();</span><br><span class="line">MyCAS::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">mytobj1</span><span class="params">(mythread)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">mytobj2</span><span class="params">(mythread)</span></span>;</span><br><span class="line">mytobj1.<span class="built_in">join</span>();</span><br><span class="line">mytobj2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//std::call_once()函数模板：能够保证函数只被调用一次（即便是在多线程的情况下）</span></span><br><span class="line"><span class="comment">//该函数的第二个参数是一个函数名；具备互斥量的能力，而且效率上比互斥量消耗的资源更少</span></span><br><span class="line"><span class="comment">//需要与一个标记结合使用，std::once_flag(结构)</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="call-once"><a href="#call-once" class="headerlink" title="call_once()"></a>call_once()</h5><p>单例类的实现方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">std::once_flag flag;<span class="comment">//未被定义的标记</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">once</span><span class="params">()</span><span class="comment">//call_once调用函数 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">m_instance = <span class="keyword">new</span> <span class="built_in">MyCAS</span>();</span><br><span class="line"><span class="type">static</span> Clear c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> MyCAS* <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::<span class="built_in">call_once</span>(flag,once);</span><br><span class="line"><span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="条件变量对象在多线程中的使用"><a href="#条件变量对象在多线程中的使用" class="headerlink" title="条件变量对象在多线程中的使用"></a>条件变量对象在多线程中的使用</h4><h5 id="condition-variable-wait-notify-one-and-notify-all"><a href="#condition-variable-wait-notify-one-and-notify-all" class="headerlink" title="condition_variable(),wait(),notify_one() and notify_all()"></a>condition_variable(),wait(),notify_one() and notify_all()</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InMessage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;InMessage()执行，插入一个元素 &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">guardmu</span><span class="params">(mymutex)</span></span>;</span><br><span class="line">msgRecvQueue.<span class="built_in">emplace_back</span>(i);</span><br><span class="line">mycond.<span class="built_in">notify_one</span>();<span class="comment">//尝试将wait的线程唤醒，并释放拿到的锁，如果有多个线程则随机唤醒一个线程wait()</span></span><br><span class="line">            <span class="comment">//mycond.notify_all();//尝试将所有wait（）唤醒,如果另外多个线程都使用了wait</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OutMessage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> command = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">guardmu</span><span class="params">(mymutex)</span></span>;</span><br><span class="line">mycond.<span class="built_in">wait</span>(guardmu, [<span class="keyword">this</span>] &#123;<span class="comment">//一个lambda表达式就是一个可调用对象</span></span><br><span class="line"><span class="keyword">if</span> (!msgRecvQueue.<span class="built_in">empty</span>())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//wait会将锁解开</span></span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//wait()用来等一个东西</span></span><br><span class="line"><span class="comment">//如果第二个参数lambda表达式返回值是true，那wait()直接返回</span></span><br><span class="line"><span class="comment">//如果第二个参数lambda表达式返回值是false，那么wait（）将解锁互斥量，并堵塞到本行</span></span><br><span class="line"><span class="comment">//堵塞到某个线程调用motify_one()成员函数为止</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果没有第二个参数，那么就跟第二个参数lambda表达式返回false效果一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//wait()被唤醒后开始工作，首先尝试重新获取互斥量锁，如果获取不到则流程卡在这里，不断获取</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//拿到锁则继续执行</span></span><br><span class="line"><span class="comment">//如果wait表达式有第二个参数（lambda），就判断这个lambda表达式，则wait()解锁继续等待下次唤醒</span></span><br><span class="line"><span class="comment">//如果为true则流程走下来，此时互斥锁还在锁定状态，</span></span><br><span class="line"><span class="comment">//如果wait（）没有第二个参数，则wait返回true流程走下来</span></span><br><span class="line">command = msgRecvQueue.<span class="built_in">front</span>();</span><br><span class="line">msgRecvQueue.<span class="built_in">pop_front</span>();</span><br><span class="line">Mguard.<span class="built_in">unlock</span>();<span class="comment">//以免锁住太长时间</span></span><br><span class="line"><span class="comment">//......</span></span><br><span class="line"><span class="comment">//灵活性</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;OutMessage（）函数执行并取出一个元素&quot;</span> &lt;&lt; command &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">std::list&lt;<span class="type">int</span>&gt; msgRecvQueue;<span class="comment">//发送的信号</span></span><br><span class="line">std::mutex mymutex;</span><br><span class="line">std::condition_variable mycond;<span class="comment">//条件变量对象声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">A a;</span><br><span class="line"><span class="function">std::thread <span class="title">mytobj</span><span class="params">(&amp;A::InMessage, &amp;a)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">mytobj1</span><span class="params">(&amp;A::OutMessage, &amp;a)</span></span>;</span><br><span class="line">mytobj.<span class="built_in">join</span>();</span><br><span class="line">mytobj1.<span class="built_in">join</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Hello World!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="async-and-future"><a href="#async-and-future" class="headerlink" title="async() and future()"></a>async() and future()</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mythread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;mythread()开始执行！&quot;</span> &lt;&lt; <span class="string">&quot;threadid = &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">std::<span class="function">chrono::milliseconds <span class="title">dura</span><span class="params">(<span class="number">5000</span>)</span></span>;</span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(dura);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;mythread()结束执行！&quot;</span> &lt;&lt; <span class="string">&quot;threadid = &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;主线程id = &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//std::future&lt;int&gt; result = std::async(std::launch::deferred, mythread);//延迟调用并且不会创建新线程，线程入口函数实际在主线程中执行</span></span><br><span class="line">    <span class="comment">//如果后面没有调用get() or wait()则不会执行线程入口函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//std::future&lt;int&gt; result = std::async(std::launch::async, mythread);//此时创建的是一个新的子线程，并调用线程入口函数</span></span><br><span class="line">    </span><br><span class="line">std::future&lt;<span class="type">int</span>&gt; result = std::<span class="built_in">async</span>(mythread);<span class="comment">//创建线程并绑定</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;continue.........!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;result = &quot;</span> &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; std::endl;<span class="comment">//get()会等待future对象得到异步线程调用后的返回值</span></span><br><span class="line"><span class="comment">//必须有返回值，否则一直等待</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/11/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8-md/Snipaste_2023-12-10_16-43-11.png" class=""><h5 id="packaged-task"><a href="#packaged-task" class="headerlink" title="packaged_task()"></a>packaged_task()</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mythread</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num&lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;mythread()开始执行！&quot;</span> &lt;&lt; <span class="string">&quot;threadid = &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">std::<span class="function">chrono::milliseconds <span class="title">dura</span><span class="params">(<span class="number">5000</span>)</span></span>;</span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(dura);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;mythread()结束执行！&quot;</span> &lt;&lt; <span class="string">&quot;threadid = &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;主线程id = &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//std::packaged_task:打包任务，把任务包装起来（包装起来的可调用对象还可以直接调用）</span></span><br><span class="line"><span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>)</span>&gt; <span class="title">mypt</span><span class="params">(mythread)</span></span>;<span class="comment">//将入口函数用packaged_task()包装起来</span></span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(std::ref(mypt), <span class="number">1</span>)</span></span>;</span><br><span class="line">t.<span class="built_in">join</span>();</span><br><span class="line">std::future&lt;<span class="type">int</span>&gt; result = mypt.<span class="built_in">get_future</span>();<span class="comment">//将future对象与packaged对象绑定到一起</span></span><br><span class="line">std::cout &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;continue.........!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/11/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8-md/Snipaste_2023-12-10_17-23-58.png" class=""><p>包装lambda表达式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lambda表达式作为可调用对象被打包</span></span><br><span class="line"><span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="type">int</span>)</span>&gt; <span class="title">mypt</span><span class="params">([](<span class="type">int</span> mypar) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">std::cout &lt;&lt; <span class="string">&quot;mypar = &quot;</span> &lt;&lt; mypar &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">std::cout &lt;&lt; <span class="string">&quot;mythread()开始执行&quot;</span> &lt;&lt; <span class="string">&quot;  线程id：&quot;</span> &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function">std::chrono::milliseconds <span class="type">const</span> dura(<span class="number">5000</span>);<span class="comment">//</span></span></span></span><br><span class="line"><span class="params"><span class="function">std::this_thread::sleep_for(dura);</span></span></span><br><span class="line"><span class="params"><span class="function">std::cout &lt;&lt; <span class="string">&quot;mythread()结束执行&quot;</span> &lt;&lt; <span class="string">&quot;  线程id：&quot;</span> &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">return</span> <span class="number">5</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"><span class="built_in">mypt</span>(<span class="number">100</span>);</span><br><span class="line">std::future&lt;<span class="type">int</span>&gt; result = mypt.<span class="built_in">get_future</span>();</span><br><span class="line">std::cout&lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><h5 id="promise"><a href="#promise" class="headerlink" title="promise()"></a>promise()</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mythread</span><span class="params">(std::promise&lt;<span class="type">int</span>&gt;&amp; temp, <span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a++;</span><br><span class="line">a *= <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">std::<span class="function">chrono::milliseconds <span class="type">const</span> <span class="title">dura</span><span class="params">(<span class="number">5000</span>)</span></span>;</span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(dura);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> result = a;<span class="comment">//保存结果</span></span><br><span class="line">temp.<span class="built_in">set_value</span>(result);<span class="comment">//结果保存到temp对象中</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mythread2</span><span class="params">(std::future&lt;<span class="type">int</span>&gt;&amp; temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> result = temp.<span class="built_in">get</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;mythread2 result = &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//std::promise类模板</span></span><br><span class="line"><span class="comment">//我们能够在某个线程中给他赋值，然后可以在其他线程中取出</span></span><br><span class="line">std::promise&lt;<span class="type">int</span>&gt; myprom;<span class="comment">//声明为一个myprom对象，保存的值类型为int</span></span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(mythread, std::ref(myprom), <span class="number">180</span>)</span></span>;</span><br><span class="line">t1.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">std::future&lt;<span class="type">int</span>&gt; fu = myprom.<span class="built_in">get_future</span>();<span class="comment">//promise和future绑定，用于获取线程返回值</span></span><br><span class="line"><span class="comment">/*auto result = fu.get();</span></span><br><span class="line"><span class="comment">std::cout &lt;&lt; &quot;result = &quot; &lt;&lt; result &lt;&lt; std::endl;*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">t2</span><span class="params">(mythread2, std::ref(fu))</span></span>;</span><br><span class="line">t2.<span class="built_in">join</span>();</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;continue.........!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/11/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8-md/Snipaste_2023-12-10_17-59-19.png" class=""><h5 id="future-其他成员函数"><a href="#future-其他成员函数" class="headerlink" title="future()其他成员函数"></a>future()其他成员函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mythread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;线程开始执行 threadid = &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">std::<span class="function">chrono::milliseconds <span class="title">dur</span><span class="params">(<span class="number">5000</span>)</span></span>;</span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(dur);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;线程执行结束 threadid = &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;主线程id = &quot;</span>&lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">std::future&lt;<span class="type">int</span>&gt; result = std::<span class="built_in">async</span>(mythread);</span><br><span class="line"><span class="comment">//枚举类型</span></span><br><span class="line">std::future_status status = result.<span class="built_in">wait_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">6</span>));</span><br><span class="line"><span class="comment">//三种状态</span></span><br><span class="line"><span class="keyword">if</span> (status == std::future_status::timeout) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;超时！！！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (status == std::future_status::ready) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;成功执行完毕！！！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (status == std::future_status::deferred) &#123;<span class="comment">//延迟</span></span><br><span class="line"><span class="comment">//std::future&lt;int&gt; result = std::async(std::launch::deferred,mythread);</span></span><br><span class="line"><span class="comment">//不会创建新线程</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;线程被延迟执行！！！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; result.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;continue.........!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/11/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8-md/PixPin_2023-12-24_18-11-03.png" class=""><h5 id="timed-mutex-and-recursive-timed-mutex"><a href="#timed-mutex-and-recursive-timed-mutex" class="headerlink" title="timed_mutex and recursive_timed_mutex"></a>timed_mutex and recursive_timed_mutex</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//带超时的互斥量std::timed_mutex 和 std::recursive_timed_mutex</span></span><br><span class="line">std::timed_mutex是带超时功能的独占互斥量</span><br><span class="line"><span class="built_in">try_lock_for</span>():参数是一段时间，是等待一段时间，如果拿到了锁，或者等待超时没拿到锁，就继续执行；</span><br><span class="line">std::<span class="function">chrono::milliseconds <span class="title">timeout</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="comment">//if (mymutex1.try_lock_lock(timeout))//等待1100毫秒来尝试获取锁</span></span><br><span class="line"><span class="keyword">if</span> (mymutex1.<span class="built_in">try_lock_until</span>(std::chrono::steady_clock::<span class="built_in">now</span>()+timeout))</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//在100毫秒内拿到了锁</span></span><br><span class="line">msgRecvQueue.<span class="built_in">push_back</span>(i);</span><br><span class="line">mymutex.<span class="built_in">unlock</span>();<span class="comment">//用完要解锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//没拿到锁</span></span><br><span class="line">std::chrono::microseconds <span class="built_in">sleeptime</span>(<span class="number">100</span>);</span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(sleeptime);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//try_lock_until():参数是未来的时间点，在现在到未来时间点这段时间内拿到锁就走下来，没拿到锁则</span></span><br><span class="line"><span class="comment">//std::recursive_timed_mutex带超时功能的递归独占互斥量(允许同一个线程多次过去同一个互斥量)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>插入and希尔排序.md</title>
      <link href="/2023/11/21/%E6%8F%92%E5%85%A5and%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F-md/"/>
      <url>/2023/11/21/%E6%8F%92%E5%85%A5and%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F-md/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p><strong>插入排序（Insertion Sort）</strong>是一种简单直观且稳定的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上通常使用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><p>插入排序的时间复杂度是O(n^2)，其中n是待排序数组的元素个数。在最坏情况下，需要进行n(n-1)&#x2F;2次比较和n-1次插入操作。在最好情况下，即待排序数组已经有序，只需要进行n-1次比较，时间复杂度为O(n)。</p><p>插入排序的空间复杂度是O(1)，因为它是就地排序，不需要使用额外的辅助空间。</p><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="type">int</span> key = nums[i];</span><br><span class="line"><span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; key) &#123;      <span class="comment">//当前元素值大于key值时（前面大于后面）将 j 位置上的元素往后移动一位到 j+1 </span></span><br><span class="line">nums[j + <span class="number">1</span>] = nums[j];      <span class="comment">// j~0是有序的，前面全部元素都大于 key ，即 j&lt;0 时结束</span></span><br><span class="line">j--;                        <span class="comment">//当到前面有元素 nums[j] &lt;= key 时结束</span></span><br><span class="line">&#125;</span><br><span class="line">nums[j + <span class="number">1</span>] = key;      <span class="comment">//将移动之后的空位赋值为 key</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p><strong>希尔排序（Shell Sort）</strong>是插入排序的一种又称“缩小增量排序”（Diminishing Increment Sort），是直接插入排序算法的一种更高效的改进版本。希尔排序是<strong>非稳定排序算法</strong>。该方法因 D.L.Shell 于 1959 年提出而得名。希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止。</p><p>希尔排序的时间复杂度为O(nlogn)，与增量序列的选择有关。</p><p>希尔排序与直接插入排序一样，并没有借助中间变量，空间复杂度为O(1)。</p><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shell_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> key;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> inc = n / <span class="number">2</span>; inc &gt; <span class="number">0</span>; inc /= <span class="number">2</span> ) &#123;      <span class="comment">//初始增量和增量变化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = inc; i &lt; n; i++) &#123;</span><br><span class="line">key = nums[i];</span><br><span class="line"><span class="type">int</span> j;</span><br><span class="line"><span class="keyword">for</span> (j = i; j &gt;= inc &amp;&amp; key &lt; nums[j - inc]; j -= inc) &#123;      <span class="comment">//相距 inc 的坐标对应的元素 nums[j - inc] &gt; ums[j] 时进行交换</span></span><br><span class="line">nums[j] = nums[j - inc];</span><br><span class="line">&#125;</span><br><span class="line">nums[j] = key;      <span class="comment">//全部大于，全部小于，找到对应位置</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums = &#123; <span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">//insert_sort(nums, n);</span></span><br><span class="line"><span class="built_in">shell_sort</span>(nums, n);</span><br><span class="line">for_each(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(),[](<span class="keyword">auto</span> num) &#123;cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><img src="/2023/11/21/%E6%8F%92%E5%85%A5and%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F-md/Snipaste_2023-11-21_20-50-32.png" class="" title="Snipaste_2023-11-21_20-50-32"><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>插入排序和希尔排序都是基于比较的排序算法，但它们在处理数据时采用了不同的策略。</p><p>插入排序的基本思想是将一个记录插入到已经排好序的有序表中，从而形成一个新的、记录数增1的有序表。它逐个比较待排序记录和已排序记录，找到合适的插入位置，直到整个序列排为有序。</p><p>希尔排序是基于插入排序的，它首先将待排序记录分割成若干子序列，分别进行插入排序，待整个序列中的记录”基本有序”时，再对全体记录进行一次插入排序。希尔排序的效率比插入排序要高，尤其是当数据量较大时。</p><p>因此，可以说<strong>希尔排序</strong>是<strong>插入排序</strong>的一种<strong>改进版本</strong>，通过更有效地组织数据来提高排序效率。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序.md</title>
      <link href="/2023/11/21/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-md/"/>
      <url>/2023/11/21/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-md/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>快速排序（Quicksort）是一种<strong>分治算法</strong>，通过不断交换数组中的元素使得数组变得有序。它的基本思想是选择一个基准元素，将数组分为两个部分，使得左边的部分的所有元素都小于等于基准元素，右边的部分的所有元素都大于等于基准元素，然后递归地排序两个子数组。</p><p>快速排序的单指针实现通常被称为<strong>单指针遍历法</strong>（Split Method），双指针实现通常被称为<strong>双指针遍历法</strong>（Partition Method）。</p><h4 id="单指针遍历法"><a href="#单指针遍历法" class="headerlink" title="单指针遍历法"></a>单指针遍历法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (right &lt;= left)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> i = left;</span><br><span class="line"><span class="type">int</span> key = nums[left];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= right; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[j] &lt;= key) &#123;      <span class="comment">//如果当前元素小于基准元素</span></span><br><span class="line">i++;      </span><br><span class="line"><span class="keyword">if</span> (i != j)</span><br><span class="line"><span class="built_in">swap</span>(nums[i], nums[j]);      <span class="comment">//慢指针填充</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">swap</span>(nums[left], nums[i]);</span><br><span class="line"><span class="built_in">quickSort</span>(nums, left, i - <span class="number">1</span>);      <span class="comment">//第 i 个元素位置已经确定（当前值 j == i）将 nums[i] 作为一个分隔</span></span><br><span class="line"><span class="built_in">quickSort</span>(nums, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><img src="/2023/11/21/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-md/Snipaste_2023-11-21_11-58-58.png" class="" title="Snipaste_2023-11-21_11-58-58"><h4 id="双指针遍历法"><a href="#双指针遍历法" class="headerlink" title="双指针遍历法"></a>双指针遍历法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (right &lt;= left)      <span class="comment">//当起点小于等于终点时直接返回，当 right == right 时没有不必进行交换因为此时只有一个元素 </span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> i = left, j = right;</span><br><span class="line"><span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= nums[left]) &#123;      <span class="comment">//从右边开始找到第一个比 nums[left] 小的元素下标</span></span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= nums[left]) &#123;      <span class="comment">//从左边开始找到第一个比 nums[left] 大的元素下标</span></span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i != j)      <span class="comment">//当满足条件的 i 和 j 在不同位置上时（相同则不必交换）</span></span><br><span class="line"><span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">swap</span>(nums[left], nums[i]);      <span class="comment">//将基准元素 nums[left] 与比当前值小的元素 nums[i] 进行交换</span></span><br><span class="line"><span class="built_in">quickSort</span>(nums, left, i - <span class="number">1</span>);      <span class="comment">//第 i 个元素位置已经确定（当前值 j == i）将 nums[i] 作为一个分隔</span></span><br><span class="line"><span class="built_in">quickSort</span>(nums, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums = &#123; <span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="built_in">quickSort</span>(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">for_each(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [](<span class="keyword">auto</span> i) &#123;cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><img src="/2023/11/21/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-md/Snipaste_2023-11-21_11-58-58.png" class="" title="Snipaste_2023-11-21_11-58-58">]]></content>
      
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线段树.md</title>
      <link href="/2023/11/20/%E7%BA%BF%E6%AE%B5%E6%A0%91-md/"/>
      <url>/2023/11/20/%E7%BA%BF%E6%AE%B5%E6%A0%91-md/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>线段树的主要作用是处理数组的<strong>区间查询</strong>（range query）和<strong>元素更新</strong>（update）操作，并支持在<strong>O(logn)<strong>的</strong>时间复杂度</strong>内进行查询和更新操作。它是一种平衡二叉树，每个节点用于维护一个区间的权值，因此可以高效地处理涉及区间修改、单点查询；区间修改、区间查询；单点修改、区间查询；连续最长区间等问题。</p><p>线段树可以用于解很多类问题，如区间修改，单点查询；区间修改，区间查询；单点修改，区间查询；连续最长区间等等。</p><p>线段树的简单实现</p><p>插入：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tree_insert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> pos, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">a[pos]++;      <span class="comment">//对路径上经过的点加1</span></span><br><span class="line"><span class="keyword">if</span> (num == right &amp;&amp; num == left)      <span class="comment">//区间只包含一个元素</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;      <span class="comment">//区间中点</span></span><br><span class="line"><span class="type">int</span> left_child = pos * <span class="number">2</span> + <span class="number">1</span>;      <span class="comment">//左孩子数组对应下标</span></span><br><span class="line"><span class="type">int</span> right_child = pos * <span class="number">2</span> + <span class="number">2</span>;      <span class="comment">//右孩子数组对应下标</span></span><br><span class="line"><span class="keyword">if</span> (num &lt;= mid)</span><br><span class="line"><span class="built_in">tree_insert</span>(a, left_child, left, mid, num);      <span class="comment">//将num插入到该区间的左孩子区间中</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">tree_insert</span>(a, right_child, mid + <span class="number">1</span>, right, num);      <span class="comment">////将num插入到该区间的右孩子区间中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">tree_search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> pos, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (num == right &amp;&amp; num == left)      <span class="comment">//该区间只有一个元素（找到该元素，返回）</span></span><br><span class="line"><span class="keyword">return</span> a[pos];</span><br><span class="line"><span class="type">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;      <span class="comment">//计算区间中点</span></span><br><span class="line"><span class="type">int</span> left_child = pos * <span class="number">2</span> + <span class="number">1</span>;      </span><br><span class="line"><span class="type">int</span> right_child = pos * <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (num &lt;= mid)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">tree_search</span>(a, left_child, left, mid, num);      <span class="comment">//在左孩子区间去寻找num</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">tree_search</span>(a, right_child, mid + <span class="number">1</span>, right, num);      <span class="comment">//在右孩子区间去寻找num</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_tree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> pos, <span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;[&quot;</span> &lt;&lt; left &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; right &lt;&lt; <span class="string">&quot;] &quot;</span> &lt;&lt; <span class="string">&quot;a[&quot;</span> &lt;&lt; pos &lt;&lt; <span class="string">&quot;]=&quot;</span> &lt;&lt; a[pos] &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//left：左孩子， right：右孩子， pos：在数组中的对应下表， a[pos]：数组中存储的值</span></span><br><span class="line"><span class="keyword">if</span> (left == right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="built_in">print_tree</span>(a, pos * <span class="number">2</span> + <span class="number">1</span>, left, mid);</span><br><span class="line"><span class="built_in">print_tree</span>(a, pos * <span class="number">2</span> + <span class="number">2</span>, mid + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">100</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">tree_insert</span>(a, <span class="number">0</span>, left, right, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">tree_insert</span>(a, <span class="number">0</span>, left, right, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">tree_insert</span>(a, <span class="number">0</span>, left, right, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">print_tree</span>(a, <span class="number">0</span>, left, right);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><img src="/2023/11/20/%E7%BA%BF%E6%AE%B5%E6%A0%91-md/Snipaste_2023-11-20_17-01-29.png" class="" title="Snipaste_2023-11-20_17-01-29">]]></content>
      
      
      
        <tags>
            
            <tag> 搜索算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序.md</title>
      <link href="/2023/11/19/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-md/"/>
      <url>/2023/11/19/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-md/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>归并排序（Merge Sort）是一种分治算法，将待排序的序列划分为若干个子序列，对每个子序列进行排序，最后将已经排序的子序列合并成一个有序的序列。其基本思想是将待排序的序列分为若干个子序列，对每个子序列进行排序，最终得到一个有序的序列。</p><p>归并排序的主要<strong>步骤</strong>：</p><p>1.将待排序的序列平均分成两个子序列，递归地对每个子序列进行排序；<br>2.将已经排序的子序列合并成一个有序的序列，具体实现方式为将相邻的两个有序子序列进行合并；<br>3.重复步骤1和2，直到序列长度为1或0，即序列已经完全有序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(<span class="number">100</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt;= right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="built_in">merge</span>(nums, left, mid);</span><br><span class="line"><span class="built_in">merge</span>(nums, mid + <span class="number">1</span>, right);</span><br><span class="line"><span class="type">int</span> leftPos = left, midPos = mid + <span class="number">1</span>, curPos = left;</span><br><span class="line"><span class="keyword">while</span> (leftPos &lt;= mid &amp;&amp; midPos &lt;= right) &#123;      <span class="comment">//公共部分</span></span><br><span class="line">arr[curPos++] = nums[leftPos] &lt;= nums[midPos] ? nums[leftPos++] : nums[midPos++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (leftPos &lt;= mid) &#123;      <span class="comment">//左边剩余部分</span></span><br><span class="line">arr[curPos++] = nums[leftPos++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (midPos &lt;= right) &#123;       <span class="comment">//右边剩余部分</span></span><br><span class="line">arr[curPos++] = nums[midPos++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt;= right; i++) nums[i] = arr[i];      <span class="comment">//将原数组中的值替换成为排序后的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums = &#123; <span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span> &#125;;</span><br><span class="line"><span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="built_in">merge</span>(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">for_each(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [](<span class="keyword">auto</span> num) &#123; cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/11/19/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-md/Snipaste_2023-11-19_17-01-27.png" class="" title="Snipaste_2023-11-19_17-01-27">]]></content>
      
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lambda表达式.md</title>
      <link href="/2023/11/14/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F-md/"/>
      <url>/2023/11/14/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F-md/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h4 id="Lambda表达式概述"><a href="#Lambda表达式概述" class="headerlink" title="Lambda表达式概述"></a>Lambda表达式概述</h4><p> Lambda表达式是现代C++在C ++ 11和更高版本中的一个新的语法糖 ，在C++11、C++14、C++17和C++20中Lambda表达的内容还在不断更新。 lambda表达式（也称为lambda函数）是在调用或作为函数参数传递的位置处定义匿名函数对象的便捷方法。通常，lambda用于封装传递给算法或异步方法的几行代码 。本文主要介绍Lambda的工作原理以及使用方法。</p><p>语法定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[函数对象参数](函数参数)修饰符-&gt;返回值类型&#123;函数体&#125;;</span><br></pre></td></tr></table></figure><h4 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h4><h5 id="函数对象参数"><a href="#函数对象参数" class="headerlink" title="函数对象参数"></a>函数对象参数</h5><p>“[]”<strong>标识</strong>一个Lambda表达式的开始，这一部分是不可以忽略的。编译器根据该引出符判断接下来的代码是否是Lambda函数，捕获列表能够捕捉上下文中的变量以供Lambda函数使用。</p><ul><li>[]：表示不捕获任何变量；</li><li>&amp;：代表以<strong>引用</strong>传递的方式捕获Lambda表达式外的变量；</li><li>&#x3D;：代表以<strong>值传递</strong>的方式捕获Lambda表达式外的变量，即以const引用的方式传值；</li><li>this：表示Lambda表达式可以使用Lambda表达式<strong>所在类的成员变量；</strong></li><li>a 或 &#x3D;a：表示以<strong>值引用</strong>的方式传递变量a，即const int a,在函数体内<strong>不可改变</strong>a的值；但是可以对Lambda表达式使用mutable修饰符修饰，使得函数对象参数可以进行赋值，但是该函数对象参数不是被修改为引用传递方式；</li><li>&amp;a：表示以引用传递的方式传递变量a，在函数体内可以改变a的值；</li><li>x，&amp;y：x为值传递方式，y为引用传值方式；</li><li>&#x3D;，&amp;x，&amp;y：除x，y为引用传递方式以外，其他参数都为值传递方式进行传递；</li><li>&amp;，x，y：除x，y为值传递方式以外，其他参数都为引用传递方式进行传递。</li></ul><h5 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h5><p>与普通函数的参数列表一致。如果不需要参数传递，则可以连同括号“()”一起省略。</p><p>无参：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [] &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Hello&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有参：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [] (string s) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Hello &quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">f</span>(world);</span><br></pre></td></tr></table></figure><h5 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h5><p>这一部分是可以省略的，常见的修饰符有两个，一个是<strong>mutable</strong>，另一个是<strong>exception</strong>。</p><p>mutable：当函数参数以值引用传递方式传递时，在函数体内是不可以修改该函数参数的值的，我们可以使用mutable修饰符，使得该函数参数可以<strong>在函数体内改变</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> test = [x] () <span class="keyword">mutable</span> &#123; x++; cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>; &#125;;</span><br><span class="line"><span class="built_in">test</span>();cout &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：2 1</span></span><br><span class="line"><span class="comment">//被mutable修饰的函数参数，该函数参数可以在函数体内改变，也就是说不会改变函数体外该变量的值，我们也可以理解为在函数体内拷贝了这个变量的同名变量</span></span><br></pre></td></tr></table></figure><p>exception：你可以使用 throw() 异常规范来指示 lambda 表达式不会引发任何异常。与普通函数一样，如果 lambda 表达式声明 C4297 异常规范且 lambda 体引发异常，Visual C++ 编译器将生成警告 throw()。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> <span class="comment">// C4297 expected </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> []() <span class="keyword">throw</span>() &#123; <span class="keyword">throw</span> <span class="number">5</span>; &#125;(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="返回值类型"><a href="#返回值类型" class="headerlink" title="返回值类型"></a>返回值类型</h5><p>Lambda表达式的返回类型会自动推导。除非你指定了返回类型，否则不必使用关键字。返回型类似于通常的方法或函数的返回型部分。但是，返回类型必须在参数列表之后，并且必须在返回类型-&gt;之前包含类型关键字。如果lambda主体仅包含一个return语句或该表达式未返回值，则可以省略Lambda表达式的return-type部分。如果lambda主体包含一个return语句，则编译器将从return表达式的类型中推断出return类型。否则，编译器将返回类型推导为void。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x1 = [](<span class="type">int</span> i)&#123; <span class="keyword">return</span> i; &#125;;</span><br></pre></td></tr></table></figure><h5 id="函数体"><a href="#函数体" class="headerlink" title="函数体"></a>函数体</h5><p> Lambda表达式的lambda主体（标准语法中的<em>复合语句</em>）可以包含普通方法或函数的主体可以包含的任何内容。普通函数和lambda表达式的主体都可以访问以下类型的变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 捕获变量</span><br><span class="line">- 形参变量</span><br><span class="line">- 局部声明的变量</span><br><span class="line">- 类数据成员，当在类内声明**`this`**并被捕获时</span><br><span class="line">- 具有静态存储持续时间的任何变量，例如全局变量</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">   [&amp;, n] (<span class="type">int</span> a) <span class="keyword">mutable</span> &#123; m = ++n + a; &#125;(<span class="number">4</span>);</span><br><span class="line">   cout &lt;&lt; m &lt;&lt; endl &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Lambda优缺点"><a href="#Lambda优缺点" class="headerlink" title="Lambda优缺点"></a>Lambda优缺点</h4><h5 id="Lambda表达式的优点"><a href="#Lambda表达式的优点" class="headerlink" title="Lambda表达式的优点"></a>Lambda表达式的优点</h5><ul><li><p>可以直接在需要调用函数的位置定义短小精悍的函数，而不需要预先定义好函数</p></li><li><p>使用Lamdba表达式变得更加紧凑，结构层次更加明显、代码可读性更好</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [](<span class="type">int</span>&amp; item)&#123;<span class="keyword">return</span> item &gt; <span class="number">2</span>&#125;);</span><br></pre></td></tr></table></figure><h5 id="Lambda表达式的缺点"><a href="#Lambda表达式的缺点" class="headerlink" title="Lambda表达式的缺点"></a>Lambda表达式的缺点</h5><ul><li>Lamdba表达式语法比较灵活，增加了阅读代码的难度</li><li>对于函数复用无能为力</li></ul><h4 id="Lamdba表达式应用于STL算法库"><a href="#Lamdba表达式应用于STL算法库" class="headerlink" title="Lamdba表达式应用于STL算法库"></a>Lamdba表达式应用于STL<strong>算法库</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for_each应用实例</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">4</span>] = &#123;<span class="number">11</span>, <span class="number">2</span>, <span class="number">33</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(a, a+<span class="number">4</span>, [=](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">bool</span> &#123; <span class="keyword">return</span> x%<span class="number">10</span> &lt; y%<span class="number">10</span>; &#125; );</span><br><span class="line">for_each(a, a+<span class="number">4</span>, [=](<span class="type">int</span> x) &#123; cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;&#125; );</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// find_if应用实例</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">10</span>;</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; coll = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">19</span>, <span class="number">5</span>, <span class="number">13</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">2</span>, <span class="number">17</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> pos = <span class="built_in">find_if</span>(coll.<span class="built_in">cbegin</span>(), coll.<span class="built_in">cend</span>(), [=](<span class="type">int</span> i) &#123;                 </span><br><span class="line">    <span class="keyword">return</span> i &gt; x &amp;&amp; i &lt; y;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// remove_if应用实例</span></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec_data = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">vec_data.<span class="built_in">erase</span>(std::<span class="built_in">remove_if</span>(vec.date.<span class="built_in">begin</span>(), vec_data.<span class="built_in">end</span>(), [](<span class="type">int</span> i) &#123; </span><br><span class="line">    <span class="keyword">return</span> n &lt; x;&#125;), vec_data.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">std::for_each(vec.date.<span class="built_in">begin</span>(), vec_data.<span class="built_in">end</span>(), [](<span class="type">int</span> i) &#123; </span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; std::endl;&#125;);</span><br></pre></td></tr></table></figure><h4 id="Lamdba表达式应用于多线程"><a href="#Lamdba表达式应用于多线程" class="headerlink" title="Lamdba表达式应用于多线程"></a>Lamdba表达式应用于多线程</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// vector 容器存储线程</span></span><br><span class="line">    std::vector&lt;std::thread&gt; workers;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        workers.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>([]() </span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;thread function\n&quot;</span>;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;main thread\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 for_each 循环每一个线程</span></span><br><span class="line">    <span class="comment">// 第三个参数赋值一个task任务</span></span><br><span class="line">    <span class="comment">// 符号&#x27;[]&#x27;会告诉编译器我们正在用一个匿名函数</span></span><br><span class="line">    <span class="comment">// lambda函数将它的参数作为线程的引用t</span></span><br><span class="line">    <span class="comment">// 然后一个一个的join</span></span><br><span class="line">    std::for_each(workers.<span class="built_in">begin</span>(), workers.<span class="built_in">end</span>(), [](std::thread &amp;t;) </span><br><span class="line">    &#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mutex;</span><br><span class="line">std::condition_variable condition;</span><br><span class="line">std::queue&lt;std::string&gt; queue_data;</span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">threadBody</span><span class="params">([&amp;]&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">std::unique_lock&lt;std::mutex&gt; lock_log(mutex);</span></span></span><br><span class="line"><span class="params"><span class="function">condition.wait(lock_log, [&amp;]&#123;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">return</span> !queue_data.front();</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;);</span></span></span><br><span class="line"><span class="params"><span class="function">std::cout &lt;&lt; <span class="string">&quot;queue data: &quot;</span> &lt;&lt; queue_data.front();</span></span></span><br><span class="line"><span class="params"><span class="function">lock_log.unlock();</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">queue_data.<span class="built_in">push</span>(<span class="string">&quot;this is my data&quot;</span>);</span><br><span class="line">condition.<span class="built_in">notity_one</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(threadBody.<span class="built_in">joinable</span>())</span><br><span class="line">&#123;</span><br><span class="line">threadBody.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++remove_if.md</title>
      <link href="/2023/11/11/remove-if-md/"/>
      <url>/2023/11/11/remove-if-md/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p><code>std::remove_if</code> 是 C++ 标准库中的一个算法，它根据指定的条件，将满足条件的元素从输入序列中移除，并返回新的逻辑结束位置。其函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">remove_if</span><span class="params">(iterator first, iterator last, <span class="type">const</span> Predicate&amp; pred)</span></span>;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>first</code> 和 <code>last</code> 是输入序列的开始和结束迭代器。</li><li><code>pred</code> 是一个函数或函数对象，用于判断哪些元素应该被移除。</li></ul><p>返回值是一个迭代器，指向输入序列中第一个被移除元素之后的位置。</p><p>下面是一个<strong>简单</strong>的实现示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> Predicate&gt;</span></span><br><span class="line"><span class="function">Iterator <span class="title">my_remove_if</span><span class="params">(Iterator first, Iterator last, <span class="type">const</span> Predicate&amp; pred)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Iterator next = first;</span><br><span class="line">    <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">pred</span>(*first)) &#123;</span><br><span class="line">            *next = *first;</span><br><span class="line">            ++next;</span><br><span class="line">        &#125;</span><br><span class="line">        ++first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个实现中，我们使用了一个 <code>next</code> 迭代器，用于保存当前处理过的最后一个不满足条件的元素的位置。然后我们遍历输入序列，对于每个元素，如果它满足条件，我们就将其保留在原位，否则我们将它移动到 <code>next</code> 所指向的位置，并将 <code>next</code> 向后移动一位。最后返回 <code>next</code>，即为新的逻辑结束位置。</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSpace</span><span class="params">(<span class="type">char</span> x)</span> </span>&#123; <span class="keyword">return</span> x == <span class="string">&#x27; &#x27;</span>; &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">string <span class="title">s2</span><span class="params">(<span class="string">&quot;Text with    spaces&quot;</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;删除之前&quot;</span>&lt;&lt;s2 &lt;&lt; endl;</span><br><span class="line">s2.<span class="built_in">erase</span>(<span class="built_in">remove_if</span>(s2.<span class="built_in">begin</span>(), s2.<span class="built_in">end</span>(), isSpace), s2.<span class="built_in">end</span>());</span><br><span class="line">cout &lt;&lt;<span class="string">&quot;删除之后&quot;</span>&lt;&lt; s2 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本例中remove_if()函数传入的第三个参数是一个判断空格的函数，那么<code>remove_if</code>将会移除字符串中所有空格，并返回一个迭代器，指向移除空格后的字符串的末尾。</p><p>对于提供的示例字符串 <code>&quot;Text with    spaces&quot;</code>，移除所有空格后，剩下的字符串是 <code>&quot;Textwithspaces&quot;</code>。因此，<code>remove_if</code>函数的返回迭代器的值应该是 <code>&quot;Textwithspaces&quot;</code> 字符串的末尾位置。</p><p>真实情况：</p><p>当 <code>std::remove_if()</code> 算法被调用时，它会<strong>重新排列序列</strong>，将所有不满足条件的元素移动到序列的前面，并将满足条件的元素（要删除元素）移动到序列的末尾。然而，它并不会减少序列的总长度，也就是说，序列的元素个数不会因为 <code>std::remove_if()</code> 的调用而减少。</p><p><code>remove_if()</code> 算法不会直接修改原始序列，而是返回一个指向新的逻辑结束位置的迭代器。如果希望将结果存储在另一个序列中，可以使用 <code>std::remove_copy_if()</code> 算法。</p><p>如果想要<strong>真正删除</strong>（对原序列进行修改），通常需要配合<strong>erase函数</strong>使用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++men_fun和men_fun_ref.md</title>
      <link href="/2023/11/09/men-fun%E5%92%8Cmen-fun-ref-md/"/>
      <url>/2023/11/09/men-fun%E5%92%8Cmen-fun-ref-md/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p><code>std::mem_fun</code> 和 <code>std::mem_fun_ref</code> 是 C++ 标准库中的函数适配器，用于调用成员函数。</p><p>以下是它们的官方定义：</p><ul><li><p><code>std::mem_fun</code>：这是一个函数对象适配器，可以将一个成员函数转换为具有固定参数的函数对象。它接受一个成员函数指针，并返回一个可以调用具有固定参数的函数对象。</p></li><li><p><code>std::mem_fun_ref</code>：这是一个函数对象适配器，可以将一个成员函数引用转换为具有固定参数的函数对象。它接受一个成员函数引用，并返回一个可以调用具有固定参数的函数对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClxECS</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">DoSomething</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Output from method DoSomething!&quot;</span> &lt;&lt; endl; <span class="comment">// 这里以输出一句话来代替具体的操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;ClxECS*&gt; vECS;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">13</span>; i++)&#123;</span><br><span class="line">    ClxECS *pECS = <span class="keyword">new</span> ClxECS;</span><br><span class="line">    vECS.<span class="built_in">push_back</span>(pECS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DoSomething</span><span class="params">(ClxECS *pECS)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pECS-&gt;<span class="built_in">DoSomething</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用for_each来实现我们想要的功能：for_each(vECS.begin(), vECS.end(), &amp;DoSomething);</p></li></ul><p>这两个适配器的目的是允许您使用成员函数作为常规函数对象进行操作，例如使用它们作为算法的参数。它们的主要区别在于 <code>std::mem_fun</code> 接受成员函数指针，而 <code>std::mem_fun_ref</code> 接受成员函数引用。这意味着 <code>std::mem_fun</code> 需要一个静态类型的对象来调用成员函数，而 <code>std::mem_fun_ref</code> 可以直接使用一个对象的引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line">list&lt;Widget *&gt; lpw;</span><br><span class="line">for_each(lpw.<span class="built_in">begin</span>(), lpw.<span class="built_in">end</span>(),<span class="built_in">mem_fun</span>(&amp;Widget::test)); <span class="comment">// pw-&gt;test();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line">vector&lt;Widget&gt; vw;</span><br><span class="line">for_each(vw.<span class="built_in">begin</span>(), vw.<span class="built_in">end</span>(),<span class="built_in">mem_fun_ref</span>(&amp;Widget::test)); <span class="comment">// w.test();</span></span><br><span class="line"><span class="comment">//成员函数有参数的情况：将值传入，再bind1st为this</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line">std::for_each(m_erased.<span class="built_in">begin</span>(), m_erased.<span class="built_in">end</span>(),std::<span class="built_in">bind1st</span>(std::<span class="built_in">mem_fun</span>(&amp;SocketSet::_replace_with_last), <span class="keyword">this</span>));</span><br><span class="line"><span class="comment">//相当于this-&gt;_replace_with_last(iter)  //iter</span></span><br></pre></td></tr></table></figure><p><strong>两者区别:</strong><br>mem_fun_ref的作用和用法跟mem_fun一样，唯一的不同就是：</p><p><strong>当容器中存放的是对象实体的时候用mem_fun_ref，</strong></p><p><strong>当容器中存放的是对象的指针的时候用mem_fun。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数对象理解及bind1st和bind2nd.md</title>
      <link href="/2023/11/09/%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E7%90%86%E8%A7%A3%E5%8F%8Abind1st%E5%92%8Cbind2nd-md/"/>
      <url>/2023/11/09/%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E7%90%86%E8%A7%A3%E5%8F%8Abind1st%E5%92%8Cbind2nd-md/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h4 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h4><p>函数对象就是重载了“()”运算符的类的对象，这样的话，对象就可以像函数一样使用。如下面的一段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test_add</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test_sub</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"> </span><br><span class="line">test_add add;</span><br><span class="line">test_sub sub;</span><br><span class="line"> </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a+b= &quot;</span> &lt;&lt; <span class="built_in">add</span>(a, b) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a-b= &quot;</span> &lt;&lt; <span class="built_in">sub</span>(a, b) &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="STL中提供使用函数对象"><a href="#STL中提供使用函数对象" class="headerlink" title="STL中提供使用函数对象"></a>STL中提供使用函数对象</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"> </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a= &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b= &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">plus&lt;<span class="type">int</span>&gt; int_plus;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a+b= &quot;</span> &lt;&lt; <span class="built_in">int_plus</span>(a, b) &lt;&lt; endl;</span><br><span class="line">minus&lt;<span class="type">int</span>&gt; int_min;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a-b= &quot;</span> &lt;&lt; <span class="built_in">int_min</span>(a, b) &lt;&lt; endl;</span><br><span class="line">negate&lt;<span class="type">int</span>&gt; int_neg;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-a= &quot;</span> &lt;&lt; <span class="built_in">int_neg</span>(a) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-b= &quot;</span> &lt;&lt; <span class="built_in">int_neg</span>(b) &lt;&lt; endl;</span><br><span class="line">multiplies&lt;<span class="type">int</span>&gt; int_multi;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a*b= &quot;</span> &lt;&lt; <span class="built_in">int_multi</span>(a, b) &lt;&lt; endl;</span><br><span class="line">divides&lt;<span class="type">int</span>&gt; int_div;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a/b = &quot;</span> &lt;&lt; <span class="built_in">int_div</span>(a, b) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b/a = &quot;</span> &lt;&lt; <span class="built_in">int_div</span>(b, a) &lt;&lt; endl;</span><br><span class="line">modulus&lt;<span class="type">int</span>&gt; int_mod;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a%b = &quot;</span> &lt;&lt; <span class="built_in">int_mod</span>(a, b) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b/a = &quot;</span> &lt;&lt; <span class="built_in">int_mod</span>(b, a) &lt;&lt; endl;</span><br><span class="line">equal_to&lt;<span class="type">int</span>&gt; int_equ;<span class="comment">//if = return 1  else return 0</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a!=b &quot;</span> &lt;&lt; <span class="built_in">int_equ</span>(a, b) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;(b-a) = a &quot;</span> &lt;&lt; <span class="built_in">int_equ</span>(<span class="built_in">int_min</span>(b, a), a) &lt;&lt; endl;</span><br><span class="line">not_equal_to&lt;<span class="type">int</span>&gt; int_not_equ;<span class="comment">//</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;not_equ a!=b &quot;</span> &lt;&lt; <span class="built_in">int_not_equ</span>(a, b) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;not_equ (b-a) = a &quot;</span> &lt;&lt; <span class="built_in">int_not_equ</span>(<span class="built_in">int_min</span>(b, a), a) &lt;&lt; endl;</span><br><span class="line">greater&lt;<span class="type">int</span>&gt; int_gre;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a&gt;b &quot;</span> &lt;&lt; <span class="built_in">int_gre</span>(a, b) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b&gt;a &quot;</span> &lt;&lt; <span class="built_in">int_gre</span>(b, a) &lt;&lt; endl;</span><br><span class="line">greater_equal&lt;<span class="type">int</span>&gt; int_gre_equ;<span class="comment">//&gt;or=</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b-a = a  &quot;</span> &lt;&lt; <span class="built_in">int_gre_equ</span>(<span class="built_in">int_min</span>(b, a), a) &lt;&lt; endl;</span><br><span class="line">less&lt;<span class="type">int</span>&gt; int_less;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;less a&lt;b &quot;</span> &lt;&lt; <span class="built_in">int_less</span>(a, b) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;less b&lt;a &quot;</span> &lt;&lt; <span class="built_in">int_less</span>(b, a) &lt;&lt; endl;</span><br><span class="line">less_equal&lt;<span class="type">int</span>&gt; int_less_equ;<span class="comment">//&lt;or=</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b-a = a  &quot;</span> &lt;&lt; <span class="built_in">int_less_equ</span>(<span class="built_in">int_min</span>(b, a), a) &lt;&lt; endl;</span><br><span class="line">logical_and&lt;<span class="type">int</span>&gt; int_logical_and;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a&amp;&amp;b = &quot;</span> &lt;&lt; <span class="built_in">int_logical_and</span>(a, b) &lt;&lt; endl;</span><br><span class="line">logical_or&lt;<span class="type">int</span>&gt; int_logical_or;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a||b = &quot;</span> &lt;&lt; <span class="built_in">int_logical_or</span>(a, b) &lt;&lt; endl;</span><br><span class="line">logical_not&lt;<span class="type">int</span>&gt; int_logical_not;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;!a = &quot;</span> &lt;&lt; <span class="built_in">int_logical_not</span>(a) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;!0 = &quot;</span> &lt;&lt; <span class="built_in">int_logical_not</span>(<span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;!-1 = &quot;</span> &lt;&lt; <span class="built_in">int_logical_not</span>(<span class="number">-1</span>) &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/11/09/%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E7%90%86%E8%A7%A3%E5%8F%8Abind1st%E5%92%8Cbind2nd-md/%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1result.png" class="" title="函数对象result"><h4 id="bind-and-ref"><a href="#bind-and-ref" class="headerlink" title="bind() and ref()"></a>bind() and ref()</h4><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b=&quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, c=&quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[], <span class="type">char</span>* env[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">auto</span> func = std::<span class="built_in">bind</span>(print, std::placeholders::_2, <span class="number">2</span>, std::placeholders::_1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/11/09/%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E7%90%86%E8%A7%A3%E5%8F%8Abind1st%E5%92%8Cbind2nd-md/Snipaste_2023-11-25_21-29-49.png" class="" title="Snipaste_2023-11-25_21-29-49"><p><code>std::ref</code> 用于取某个变量的引用，引入其是为了解决函数式编程（如std::bind）的一些传参问题。</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>&amp; n1, <span class="type">int</span>&amp; n2, <span class="type">const</span> <span class="type">int</span>&amp; n3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;In function: &quot;</span> &lt;&lt; n1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; n2 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; n3 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    ++n1; <span class="comment">// increments the copy of n1 stored in the function object</span></span><br><span class="line">    ++n2; <span class="comment">// increments the main()&#x27;s n2</span></span><br><span class="line">    <span class="comment">// ++n3; // compile error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n1 = <span class="number">1</span>, n2 = <span class="number">2</span>, n3 = <span class="number">3</span>;</span><br><span class="line">    std::function&lt;<span class="type">void</span>()&gt; bound_f = std::<span class="built_in">bind</span>(f, n1, std::<span class="built_in">ref</span>(n2), std::<span class="built_in">cref</span>(n3));</span><br><span class="line">    n1 = <span class="number">10</span>;</span><br><span class="line">    n2 = <span class="number">11</span>;</span><br><span class="line">    n3 = <span class="number">12</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Before function: &quot;</span> &lt;&lt; n1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; n2 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; n3 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="built_in">bound_f</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;After function: &quot;</span> &lt;&lt; n1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; n2 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; n3 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Before function: 10 11 12</span><br><span class="line">In function: 1 11 12</span><br><span class="line">After function: 10 12 12</span><br></pre></td></tr></table></figure><p>注意:</p><ul><li><strong>std::bind</strong>的函数参数默认使用的是<strong>拷贝</strong>， 如果需要使用引用，则需要配合<strong>std::ref</strong>。</li></ul><p>官方用例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2, <span class="type">int</span> n3, <span class="type">const</span> <span class="type">int</span>&amp; n4, <span class="type">int</span> n5)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; n1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; n2 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; n3 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; n4 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; n5 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">(<span class="type">int</span> n1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print_sum</span><span class="params">(<span class="type">int</span> n1, <span class="type">int</span> n2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; n1+n2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> data = <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;  <span class="comment">// for _1, _2, _3...</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// demonstrates argument reordering and pass-by-reference</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">7</span>;</span><br><span class="line">    <span class="comment">// (_1 and _2 are from std::placeholders, and represent future</span></span><br><span class="line">    <span class="comment">// arguments that will be passed to f1)</span></span><br><span class="line">    <span class="keyword">auto</span> f1 = std::<span class="built_in">bind</span>(f, _2, <span class="number">42</span>, _1, std::<span class="built_in">cref</span>(n), n);</span><br><span class="line">    n = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">f1</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1001</span>); <span class="comment">// 1 is bound by _1, 2 is bound by _2, 1001 is unused</span></span><br><span class="line">                    <span class="comment">// makes a call to f(2, 42, 1, n, 7)</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// nested bind subexpressions share the placeholders</span></span><br><span class="line">    <span class="keyword">auto</span> f2 = std::<span class="built_in">bind</span>(f, _3, std::<span class="built_in">bind</span>(g, _3), _3, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">f2</span>(<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>); <span class="comment">// makes a call to f(12, g(12), 12, 4, 5);</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// common use case: binding a RNG with a distribution</span></span><br><span class="line">    std::default_random_engine e;</span><br><span class="line">    std::uniform_int_distribution&lt;&gt; <span class="built_in">d</span>(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">auto</span> rnd = std::<span class="built_in">bind</span>(d, e); <span class="comment">// a copy of e is stored in rnd</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>; n&lt;<span class="number">10</span>; ++n)</span><br><span class="line">        std::cout &lt;&lt; <span class="built_in">rnd</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// bind to a pointer to member function</span></span><br><span class="line">    Foo foo;</span><br><span class="line">    <span class="keyword">auto</span> f3 = std::<span class="built_in">bind</span>(&amp;Foo::print_sum, &amp;foo, <span class="number">95</span>, _1);</span><br><span class="line">    <span class="built_in">f3</span>(<span class="number">5</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// bind to a pointer to data member</span></span><br><span class="line">    <span class="keyword">auto</span> f4 = std::<span class="built_in">bind</span>(&amp;Foo::data, _1);</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">f4</span>(foo) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// smart pointers can be used to call members of the referenced objects, too</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">f4</span>(std::<span class="built_in">make_shared</span>&lt;Foo&gt;(foo)) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">              &lt;&lt; <span class="built_in">f4</span>(std::<span class="built_in">make_unique</span>&lt;Foo&gt;(foo)) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/11/09/%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E7%90%86%E8%A7%A3%E5%8F%8Abind1st%E5%92%8Cbind2nd-md/Snipaste_2023-11-25_21-35-14.png" class="" title="Snipaste_2023-11-25_21-35-14"><h4 id="binder1st-，binder2nd使用方法"><a href="#binder1st-，binder2nd使用方法" class="headerlink" title="binder1st ，binder2nd使用方法"></a>binder1st ，binder2nd使用方法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"> </span><br><span class="line">binder1st&lt;plus&lt;<span class="type">int</span>&gt;&gt; b1st_plus = <span class="built_in">bind1st</span>(<span class="built_in">plus</span>&lt;<span class="type">int</span>&gt;(), <span class="number">10</span>);</span><br><span class="line">binder1st&lt;minus&lt;<span class="type">int</span>&gt;&gt; b1st_minus = <span class="built_in">bind1st</span>(<span class="built_in">minus</span>&lt;<span class="type">int</span>&gt;(), <span class="number">10</span>);</span><br><span class="line"> </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;10+b=&quot;</span> &lt;&lt; <span class="built_in">b1st_plus</span>(b) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;10-5=&quot;</span> &lt;&lt; <span class="built_in">b1st_minus</span>(<span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">binder2nd&lt;plus&lt;<span class="type">int</span>&gt;&gt; b2nd_plus = <span class="built_in">bind2nd</span>(<span class="built_in">plus</span>&lt;<span class="type">int</span>&gt;(), <span class="number">10</span>);</span><br><span class="line">binder2nd&lt;minus&lt;<span class="type">int</span>&gt;&gt; b2nd_minus = <span class="built_in">bind2nd</span>(<span class="built_in">minus</span>&lt;<span class="type">int</span>&gt;(), <span class="number">10</span>);</span><br><span class="line"> </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b+10=&quot;</span> &lt;&lt; <span class="built_in">b2nd_plus</span>(b) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;5-10=&quot;</span> &lt;&lt; <span class="built_in">b2nd_minus</span>(<span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用count_if获得容器v1中大于或等于4的个数</span></span><br><span class="line"><span class="type">int</span> count = <span class="built_in">count_if</span>(v1.<span class="built_in">begin</span>(),v1.<span class="built_in">end</span>(),<span class="built_in">bind1st</span>(<span class="built_in">less_equal</span>&lt;<span class="type">int</span>&gt;(),<span class="number">4</span>));</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;bind1st v1 &gt;= 4 count=&quot;</span> &lt;&lt; count &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">count = <span class="built_in">count_if</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">greater_equal</span>&lt;<span class="type">int</span>&gt;(), <span class="number">4</span>));</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;bind2nd v1 &gt;= 4 count=&quot;</span> &lt;&lt; count &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即当使用binder1st创建bind1st()后调用时，传入的是第二个参数，已经给定的默认参数是第一个(即绑定的是第一个参数)；</p><p>反之使用binder2nd创建bind2nd()后调用时，传入的是第一个参数，已经给定的默认参数是第二个(即绑定的是第二个参数)。</p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> oper_fun, <span class="keyword">typename</span> param&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test_binder1st</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">test_binder1st</span>(oper_fun operation, param first_param)</span><br><span class="line">&#123;</span><br><span class="line">oper = operation;</span><br><span class="line">first = first_param;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">param <span class="title">operator</span> <span class="params">()</span><span class="params">(param second)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">oper</span>(first, second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">oper_fun oper;</span><br><span class="line">param first;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> oper_fun, <span class="keyword">typename</span> param&gt;</span></span><br><span class="line"><span class="function">test_binder1st&lt;oper_fun, param&gt; <span class="title">test_bind1st</span><span class="params">(oper_fun operation, param first)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">test_binder1st</span>&lt;oper_fun, param&gt;(operation, first);<span class="comment">//调用的是上面test_binder1st的构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"> </span><br><span class="line">test_binder1st&lt;plus&lt;<span class="type">int</span>&gt;, <span class="type">int</span>&gt; b1st_plus = <span class="built_in">test_bind1st</span>(<span class="built_in">plus</span>&lt;<span class="type">int</span>&gt;(), <span class="number">10</span>);</span><br><span class="line">test_binder1st&lt;minus&lt;<span class="type">int</span>&gt;, <span class="type">int</span>&gt; b1st_minus = <span class="built_in">test_bind1st</span>(<span class="built_in">minus</span>&lt;<span class="type">int</span>&gt;(), <span class="number">10</span>);</span><br><span class="line"> </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;10+b=&quot;</span> &lt;&lt; <span class="built_in">b1st_plus</span>(b) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;10-5=&quot;</span> &lt;&lt; <span class="built_in">b1st_minus</span>(<span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用count_if获得容器v1中大于或等于4的个数</span></span><br><span class="line"><span class="type">int</span> count = <span class="built_in">count_if</span>(v1.<span class="built_in">begin</span>(),v1.<span class="built_in">end</span>(),<span class="built_in">test_bind1st</span>(<span class="built_in">less_equal</span>&lt;<span class="type">int</span>&gt;(),<span class="number">4</span>));</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;bind1st v1 &gt;= 4 count=&quot;</span> &lt;&lt; count &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2023/11/09/%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E7%90%86%E8%A7%A3%E5%8F%8Abind1st%E5%92%8Cbind2nd-md/image-20231110175711735.png" class="" title="image-20231110175711735">]]></content>
      
      
      
        <tags>
            
            <tag> C++特性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo.md</title>
      <link href="/2023/11/09/hexo-md/"/>
      <url>/2023/11/09/hexo-md/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init [folder]</span><br></pre></td></tr></table></figure><p>新建一个网站。如果没有设置 <code>folder</code> ，Hexo 默认在目前的文件夹建立网站。</p><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 config.yml中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>-p, –pass</td><td>自定义新文章路径</td></tr><tr><td>-r, –replace</td><td>如果存在同名文章，将其替换</td></tr><tr><td>-s, –slug</td><td>文章的Slug作为新文章的文件名和发布后的URL</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new post 博客名.md</span><br></pre></td></tr></table></figure><h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><p>启动服务,生成页面本地预览</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s  或 hexo service</span><br></pre></td></tr></table></figure><h3 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure><p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p><p>在某些情况（尤其是更换主题后），如果发现对站点的更改无论如何也不生效，可能需要运行该命令。</p><h4 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>部署网站。</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-g</code>, <code>--generate</code></td><td align="left">部署之前预先生成静态文件</td></tr></tbody></table><p>该命令可以简写为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p>一般执行顺序为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean       清除静态缓存</span><br><span class="line">hexo g           生成博客文章</span><br><span class="line">hexo s           生成页面进行本地预览</span><br><span class="line">hexo d           部署博客文章</span><br></pre></td></tr></table></figure><h4 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo migrate &lt;type&gt;</span><br></pre></td></tr></table></figure><p>从其他博客系统 迁移内容。</p><h4 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h4><h5 id="显示草稿"><a href="#显示草稿" class="headerlink" title="显示草稿"></a>显示草稿</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --draft</span><br></pre></td></tr></table></figure><h5 id="简洁模式"><a href="#简洁模式" class="headerlink" title="简洁模式"></a>简洁模式</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo --silent</span><br></pre></td></tr></table></figure><p>隐藏终端信息。</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo相关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++for_each.md</title>
      <link href="/2023/11/08/for-each-md/"/>
      <url>/2023/11/08/for-each-md/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>头文件：algorithm</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>​for_each()函数是C++标准库中的一种算法，用于对指定范围内的元素进行操作。它接受三个参数：第一个参数是要操作的容器的起始迭代器，第二个参数是要操作结束的迭代器，第三个是一元函数类型（回调函数）。第三个参数应该是实现了函数调用操作的一元函数对象或函数指针。这个函数将对输入范围内的每个元素进行操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIt</span>, <span class="keyword">class</span> <span class="title class_">UnaryFunction</span>&gt;  </span><br><span class="line"><span class="function">UnaryFunction <span class="title">for_each</span><span class="params">(InputIt first, InputIt last, UnaryFunction f)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><p>​当我们不使用for_each()时</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(a, a+<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(<span class="type">int</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator itor = v.<span class="built_in">begin</span>();itor!=v.<span class="built_in">end</span>();++itor)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;*itor&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="需了解"><a href="#需了解" class="headerlink" title="需了解"></a>需了解</h4><p>​bind1st或bind2nd函数：<code>bind1st</code> 和 <code>bind2nd</code> 是 C++ 标准库中的两个函数对象适配器，用于将二元函数对象（也就是接受两个参数的函数）转换成一元函数对象（也就是只接受一个参数的函数）。这两个函数的使用方法相似，只是参数位置有所不同。</p><p>​<code>bind1st</code> 将二元函数对象的第一个参数绑定为指定的值，生成一元函数对象。而 <code>bind2nd</code> 则将二元函数对象的第二个参数绑定为指定的值。</p><p>​这两个函数的使用场景包括但不限于 C++ 标准库中的算法，如 <code>std::find_if</code> 或 <code>std::for_each</code>，这样你就可以在算法中使用自定义的二元函数。</p><p>bind1st 的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 使用 bind1st 将二元函数 (int, int) -&gt; bool 转为一元函数 (int) -&gt; bool  </span></span><br><span class="line">    <span class="keyword">auto</span> is_even = std::<span class="built_in">bind1st</span>(std::<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;(), <span class="number">0</span>);  </span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">even_vec</span><span class="params">(vec.begin(), vec.end())</span></span>;  </span><br><span class="line">    std::<span class="built_in">remove_if</span>(even_vec.<span class="built_in">begin</span>(), even_vec.<span class="built_in">end</span>(), is_even);  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 输出剩余的偶数  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : even_vec) &#123;  </span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​这个例子中，我们创建了一个新的函数对象 <code>is_even</code>，它接受一个参数并判断该参数是否为偶数。注意，虽然 <code>std::greater&lt;int&gt;()</code> 是一个接受两个参数的函数，但通过 <code>bind1st</code>，我们将其转换为一个接受一个参数的函数。在判断一个数是否为偶数时，我们将0作为第二个参数传递给 <code>std::greater&lt;int&gt;()</code>。如果该数大于0（即不是偶数），则 <code>std::greater&lt;int&gt;()</code> 返回 true，否则返回 false。然后我们使用 <code>std::remove_if</code> 算法删除所有满足 <code>is_even</code> 的元素。</p><p>请注意，从 C++11 开始，推荐使用更强大、更灵活的 <code>std::bind</code> 和 lambda 表达式替代 <code>bind1st</code> 和 <code>bind2nd</code>，因为这两个函数功能有限，而且可能在某些情况下产生混淆和错误。</p><p>​ptr_fun是一个将普通函数适配成仿函数的配接器（adapter）。它可以将一般函数当作仿函数使用，使得能够将一般函数当做仿函数传给STL算法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> _Arg1,  </span></span><br><span class="line"><span class="function">    <span class="keyword">class</span> _Arg2,  </span></span><br><span class="line"><span class="function">    <span class="keyword">class</span> _Result&gt; <span class="keyword">inline</span>  </span></span><br><span class="line"><span class="function">    pointer_to_binary_function&lt;_Arg1, _Arg2, _Result,  </span></span><br><span class="line"><span class="function">        _<span class="title">Result</span><span class="params">(__clrcall *)</span><span class="params">(_Arg1, _Arg2)</span>&gt;  </span></span><br><span class="line"><span class="function">            <span class="title">ptr_fun</span><span class="params">(_Result (__clrcall *_Left)(_Arg1, _Arg2))</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;    <span class="comment">// return pointer_to_binary_function functor adapter  </span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">pointer_to_binary_function</span>&lt;_Arg1, _Arg2, _Result,  </span><br><span class="line">        _Result (__clrcall *)(_Arg1, _Arg2)&gt;(_Left));  </span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure><p>​ptr_fun将普通函数(两个参数, 如果有多个参数, 要改用boost::bind)适配成bind1st或bind2nd能够使用的functor，否则对bind1st或bind2nd直接绑定普通函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>    </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;    </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> arg1, <span class="type">int</span> arg2)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    std::cout&lt;&lt; <span class="string">&quot;arg1 = &quot;</span> &lt;&lt; arg1 &lt;&lt; std::endl;    </span><br><span class="line">    std::cout&lt;&lt; <span class="string">&quot;arg2 = &quot;</span> &lt;&lt; arg2 &lt;&lt; std::endl;    </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> sum = arg1 + arg2;    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sum = &quot;</span> &lt;&lt; sum &lt;&lt; std::endl;    </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> sum;    </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[], <span class="type">char</span> *env[])</span>  </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="built_in">bind1st</span>(<span class="built_in">ptr_fun</span>(sum), <span class="number">1</span>)(<span class="number">2</span>);        <span class="comment">// the same as sum(1,2)    </span></span><br><span class="line">    <span class="built_in">bind2nd</span>(<span class="built_in">ptr_fun</span>(sum), <span class="number">1</span>)(<span class="number">2</span>);        <span class="comment">// the same as sum(2,1)    </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h4 id="for-each"><a href="#for-each" class="headerlink" title="for_each()"></a>for_each()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> Function&gt;</span></span><br><span class="line"><span class="function">Function <span class="title">for_each</span><span class="params">(InputIterator beg, InputIterator end, Function f)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(beg != end) </span><br><span class="line">    <span class="built_in">f</span>(*beg++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​for_each()只能配合global function和function object。</p><h4 id="Procedure-Based与for-each-搭配"><a href="#Procedure-Based与for-each-搭配" class="headerlink" title="Procedure Based与for_each()搭配"></a><strong>Procedure Based与for_each()搭配</strong></h4><p>1.不传入参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> i )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(a, a+<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(<span class="type">int</span>))</span></span>;</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), fun);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.传入参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> i, <span class="type">const</span> <span class="type">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;str&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(a, a+<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(<span class="type">int</span>))</span></span>;</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">ptr_fun</span>(fun), <span class="string">&quot;Element:&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​function adapter 将global function 转成function object , 然后再用bind2nd() 将参数bind成一个function object。</p><h4 id="Object-Oriented-与for-each-搭配"><a href="#Object-Oriented-与for-each-搭配" class="headerlink" title="Object Oriented 与for_each 搭配"></a><strong>Object Oriented 与for_each 搭配</strong></h4><p>1、不传入参数，使用function object</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Play</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Play</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;new a Play&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Play</span>(<span class="type">const</span> Play&amp;)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;new a copy Play&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Play</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;dispose a Play&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vc</span><span class="params">(a, a+<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(<span class="type">int</span>))</span></span>;</span><br><span class="line">    for_each(vc.<span class="built_in">begin</span>(), vc.<span class="built_in">end</span>(), <span class="built_in">Play</span>());</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;See something&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">new a Play</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">new a copy Play</span><br><span class="line">dispose a Play</span><br><span class="line">dispose a Play</span><br><span class="line">See something</span><br></pre></td></tr></table></figure><p>​Play() 生成一个临时的匿名的Play对象，传入for_each 函数里，然后执行完for_each 函数后，return一个function时，Play用复制构造函数生成一个Play对象，然后两个Play对象的生命周期都结束，于是依次销毁。</p><p>2.传入参数</p><p>​可以通过构造函数的技巧传入参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Play</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str;</span><br><span class="line">    <span class="built_in">Play</span>(<span class="type">const</span> <span class="type">char</span>* s):<span class="built_in">str</span>(s) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;str&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vc</span><span class="params">(a, a+<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(<span class="type">int</span>))</span></span>;</span><br><span class="line">    for_each(vc.<span class="built_in">begin</span>(), vc.<span class="built_in">end</span>(), <span class="built_in">Play</span>(<span class="string">&quot;Element:&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Member-function-与-for-each-搭配"><a href="#Member-function-与-for-each-搭配" class="headerlink" title="Member function 与 for_each 搭配"></a><strong>Member function 与 for_each 搭配</strong></h4><p><strong>1、不传入参数</strong></p><p>通过mem_fun_ref() 这个funtion adapater 将 member funtion 转成 function object。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Door</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">open</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;open door horizontally&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoorController</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    vector&lt;Door&gt; _doorVec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addDoor</span><span class="params">(Door door)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _doorVec.<span class="built_in">push_back</span>(door);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">openDoor</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        for_each(_doorVec.<span class="built_in">begin</span>(), _doorVec.<span class="built_in">end</span>(), <span class="built_in">mem_fun_ref</span>(&amp;Door::open));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DoorController dc;</span><br><span class="line">    dc.<span class="built_in">addDoor</span>(<span class="built_in">Door</span>());</span><br><span class="line">    dc.<span class="built_in">addDoor</span>(<span class="built_in">Door</span>());</span><br><span class="line">    dc.<span class="built_in">openDoor</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><blockquote><p>open door horizontally<br>open door horizontally</p></blockquote><p><strong>值得注意的是，mem_fun_ref() 用在 object 的 member function。</strong>若要搭配多态，vector必须放pointer，也就是得使用object pointer的member function，此时得使用mem_fun()将member function转成function object。</p><p><strong>2、传入参数</strong></p><p>要使用 bind2nd</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractDoor</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span> <span class="type">const</span> </span>= <span class="number">0</span>; <span class="comment">//定义纯虚函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AbstractDoor</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HorizontalDoor</span>: <span class="keyword">public</span> AbstractDoor</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;str&lt;&lt;<span class="string">&quot;open door horizontally&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VerticalDoor</span>: <span class="keyword">public</span> AbstractDoor</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;str&lt;&lt;<span class="string">&quot;open door vertically&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoorController</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    vector&lt;AbstractDoor*&gt; _doorVec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addDoor</span><span class="params">(AbstractDoor* door)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _doorVec.<span class="built_in">push_back</span>(door);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">openDoor</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        for_each(_doorVec.<span class="built_in">begin</span>(), _doorVec.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">mem_fun</span>(&amp;AbstractDoor::open), <span class="string">&quot;Jhon &quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">DoorController</span>() </span><br><span class="line">    &#123;</span><br><span class="line">        for_each(_doorVec.<span class="built_in">begin</span>(), _doorVec.<span class="built_in">end</span>(), [](AbstractDoor* p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> p;</span><br><span class="line">            p = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DoorController dc;</span><br><span class="line">    dc.<span class="built_in">addDoor</span>(<span class="keyword">new</span> <span class="built_in">HorizontalDoor</span>());</span><br><span class="line">    dc.<span class="built_in">addDoor</span>(<span class="keyword">new</span> <span class="built_in">VerticalDoor</span>());</span><br><span class="line">    dc.<span class="built_in">openDoor</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面用到mem_fun_ref 和 mem_fun </p><p>引用一句很重要的用法：</p><blockquote><p>mem_fun_ref的作用和用法跟mem_fun一样，唯一的不同就是：当容器中存放的是对象实体的时候用mem_fun_ref，当容器中存放的是对象的指针的时候用mem_fun。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> C++特性 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
